# Мьютексы (Mutex)

<Meta>
reading_time: 9
</Meta>

<Overview>
1. **Мьютекс** — механизм взаимного исключения (mutual exclusion)
2. **sync.Mutex** — базовый мьютекс (Lock/Unlock)
3. **sync.RWMutex** — мьютекс для чтения/записи (много читателей, один писатель)
4. **Критическая секция** — код между Lock и Unlock
5. **defer Unlock** — гарантированное освобождение мьютекса
6. **Передача по указателю** — мьютекс нельзя копировать
</Overview>

<Theory>
### Что такое мьютекс?

**Мьютекс (mutex)** — от "mutual exclusion" (взаимное исключение). Это замок, который гарантирует: только одна горутина может выполнять защищённый код в любой момент времени.

```go
var mu sync.Mutex

mu.Lock()   // закрыть замок
// критическая секция — здесь только одна горутина
mu.Unlock() // открыть замок
```

### Критическая секция

Код между `Lock()` и `Unlock()` называется **критической секцией**:

```go
mu.Lock()
// === КРИТИЧЕСКАЯ СЕКЦИЯ ===
balance += amount
transactions++
// === КОНЕЦ КРИТИЧЕСКОЙ СЕКЦИИ ===
mu.Unlock()
```

Если горутина A держит замок, горутина B будет **заблокирована** на `Lock()` пока A не вызовет `Unlock()`.

### Всегда используйте defer!

```go
// ПЛОХО — легко забыть Unlock
mu.Lock()
if condition {
    return  // Упс! Unlock не вызван = дедлок!
}
mu.Unlock()

// ХОРОШО — defer гарантирует Unlock
mu.Lock()
defer mu.Unlock()
if condition {
    return  // Unlock вызовется автоматически
}
```

### sync.Mutex vs sync.RWMutex

| Тип | Lock | Unlock | Особенность |
|-----|------|--------|-------------|
| `Mutex` | Эксклюзивный | Один владелец | Простой |
| `RWMutex` | Для записи | + RLock/RUnlock для чтения | Много читателей |

### RWMutex — когда много читателей

```go
var rwmu sync.RWMutex
var cache map[string]string

// Чтение — много одновременно
func get(key string) string {
    rwmu.RLock()
    defer rwmu.RUnlock()
    return cache[key]
}

// Запись — только одна горутина
func set(key, value string) {
    rwmu.Lock()
    defer rwmu.Unlock()
    cache[key] = value
}
```

### Мьютекс нельзя копировать!

```go
type SafeCounter struct {
    mu sync.Mutex
    count int
}

// НЕПРАВИЛЬНО — копируется вместе с мьютексом!
func (c SafeCounter) Value() int {
    c.mu.Lock()  // блокируем копию мьютекса
    defer c.mu.Unlock()
    return c.count
}

// ПРАВИЛЬНО — используем указатель
func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}
```

### Дедлок (Deadlock)

Ситуация, когда горутины ждут друг друга вечно:

```go
// ДЕДЛОК!
mu.Lock()
mu.Lock()  // Ждём освобождения... себя самого

// ДЕДЛОК между горутинами
// Горутина 1: Lock(A), затем Lock(B)
// Горутина 2: Lock(B), затем Lock(A)
```

**Правило:** Всегда захватывайте мьютексы в одном порядке!

### Мьютекс vs Каналы

Мантра Go: "Don't communicate by sharing memory; share memory by communicating."

| Мьютексы | Каналы |
|----------|--------|
| Защита данных | Передача данных |
| Простые случаи | Сложная координация |
| Меньше накладных расходов | Более идиоматично |
</Theory>

<Syntax>
### sync.Mutex

```go
var mu sync.Mutex

mu.Lock()
// критическая секция
mu.Unlock()

// Или с defer
mu.Lock()
defer mu.Unlock()
// критическая секция
```

### sync.RWMutex

```go
var rwmu sync.RWMutex

// Для записи (эксклюзивно)
rwmu.Lock()
// запись
rwmu.Unlock()

// Для чтения (разделяемо)
rwmu.RLock()
// чтение
rwmu.RUnlock()
```
</Syntax>

<Examples>
кода

### Базовый Mutex

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mu      sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    
    for i := 0; i < 1000; i++ {
        mu.Lock()
        counter++
        mu.Unlock()
    }
}

func main() {
    var wg sync.WaitGroup
    
    wg.Add(3)
    go increment(&wg)
    go increment(&wg)
    go increment(&wg)
    
    wg.Wait()
    fmt.Println("Counter:", counter)  // 3000
}
```

### Mutex с defer

```go
package main

import (
    "fmt"
    "sync"
)

type BankAccount struct {
    mu      sync.Mutex
    balance float64
}

func (a *BankAccount) Deposit(amount float64) {
    a.mu.Lock()
    defer a.mu.Unlock()  // ✅ Гарантированно освободится
    
    if amount <= 0 {
        return  // Unlock вызовется автоматически
    }
    
    a.balance += amount
}

func (a *BankAccount) Withdraw(amount float64) bool {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if amount > a.balance {
        return false
    }
    
    a.balance -= amount
    return true
}

func (a *BankAccount) Balance() float64 {
    a.mu.Lock()
    defer a.mu.Unlock()
    return a.balance
}

func main() {
    account := &BankAccount{balance: 1000}
    var wg sync.WaitGroup
    
    // Параллельные операции
    for i := 0; i < 10; i++ {
        wg.Add(2)
        go func() {
            defer wg.Done()
            account.Deposit(100)
        }()
        go func() {
            defer wg.Done()
            account.Withdraw(50)
        }()
    }
    
    wg.Wait()
    fmt.Printf("Final balance: %.2f\n", account.Balance())
}
```

### RWMutex — много читателей

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Cache struct {
    mu   sync.RWMutex
    data map[string]string
}

func NewCache() *Cache {
    return &Cache{data: make(map[string]string)}
}

func (c *Cache) Set(key, value string) {
    c.mu.Lock()          // Эксклюзивная блокировка
    defer c.mu.Unlock()
    
    fmt.Printf("Writing: %s = %s\n", key, value)
    c.data[key] = value
}

func (c *Cache) Get(key string) (string, bool) {
    c.mu.RLock()         // Разделяемая блокировка
    defer c.mu.RUnlock()
    
    value, ok := c.data[key]
    return value, ok
}

func main() {
    cache := NewCache()
    var wg sync.WaitGroup
    
    // 1 писатель
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            cache.Set("key", fmt.Sprintf("value-%d", i))
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // 5 читателей (могут читать одновременно)
    for r := 0; r < 5; r++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for i := 0; i < 10; i++ {
                if val, ok := cache.Get("key"); ok {
                    fmt.Printf("Reader %d: %s\n", id, val)
                }
                time.Sleep(50 * time.Millisecond)
            }
        }(r)
    }
    
    wg.Wait()
}
```

### Встраивание мьютекса в структуру

```go
package main

import (
    "fmt"
    "sync"
)

type SafeMap struct {
    sync.RWMutex  // встраивание
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{data: make(map[string]int)}
}

func (m *SafeMap) Set(key string, value int) {
    m.Lock()        // вызываем напрямую
    defer m.Unlock()
    m.data[key] = value
}

func (m *SafeMap) Get(key string) (int, bool) {
    m.RLock()
    defer m.RUnlock()
    val, ok := m.data[key]
    return val, ok
}

func (m *SafeMap) Inc(key string) {
    m.Lock()
    defer m.Unlock()
    m.data[key]++
}

func main() {
    sm := NewSafeMap()
    var wg sync.WaitGroup
    
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            sm.Inc("counter")
        }()
    }
    
    wg.Wait()
    val, _ := sm.Get("counter")
    fmt.Println("Counter:", val)  // 100
}
```

### Защита сложной структуры

```go
package main

import (
    "fmt"
    "sync"
)

type User struct {
    ID    int
    Name  string
    Score int
}

type UserStore struct {
    mu    sync.RWMutex
    users map[int]*User
}

func NewUserStore() *UserStore {
    return &UserStore{users: make(map[int]*User)}
}

func (s *UserStore) Add(user *User) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.users[user.ID] = user
}

func (s *UserStore) Get(id int) (*User, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    user, ok := s.users[id]
    if !ok {
        return nil, false
    }
    
    // Возвращаем копию!
    copy := *user
    return &copy, true
}

func (s *UserStore) UpdateScore(id, delta int) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    user, ok := s.users[id]
    if !ok {
        return false
    }
    user.Score += delta
    return true
}

func (s *UserStore) List() []*User {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    result := make([]*User, 0, len(s.users))
    for _, u := range s.users {
        copy := *u
        result = append(result, &copy)
    }
    return result
}

func main() {
    store := NewUserStore()
    var wg sync.WaitGroup
    
    // Добавляем пользователей
    for i := 1; i <= 5; i++ {
        store.Add(&User{ID: i, Name: fmt.Sprintf("User%d", i), Score: 0})
    }
    
    // Параллельное обновление
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            store.UpdateScore(1, 1)
        }()
    }
    
    wg.Wait()
    
    user, _ := store.Get(1)
    fmt.Printf("User 1 score: %d\n", user.Score)  // 100
}
```

### TryLock (Go 1.18+)

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var mu sync.Mutex

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    if mu.TryLock() {  // Попытка захватить без блокировки
        defer mu.Unlock()
        
        fmt.Printf("Worker %d: got lock\n", id)
        time.Sleep(100 * time.Millisecond)
    } else {
        fmt.Printf("Worker %d: lock busy, skipping\n", id)
    }
}

func main() {
    var wg sync.WaitGroup
    
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    
    wg.Wait()
}
```

### Избегаем deadlock

```go
package main

import (
    "fmt"
    "sync"
)

// ❌ DEADLOCK — несогласованный порядок блокировки
func deadlock() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup
    
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        mu1.Lock()
        // time.Sleep(1 * time.Millisecond)
        mu2.Lock()  // Ждёт mu2, которая занята другой горутиной
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        defer wg.Done()
        mu2.Lock()
        // time.Sleep(1 * time.Millisecond)
        mu1.Lock()  // Ждёт mu1, которая занята другой горутиной
        mu1.Unlock()
        mu2.Unlock()
    }()
    
    wg.Wait()
}

// ✅ Фиксированный порядок блокировки
func noDeadlock() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup
    
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        mu1.Lock()  // Всегда mu1 первым
        mu2.Lock()
        fmt.Println("Goroutine 1")
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        defer wg.Done()
        mu1.Lock()  // Всегда mu1 первым
        mu2.Lock()
        fmt.Println("Goroutine 2")
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    wg.Wait()
}

func main() {
    noDeadlock()
    fmt.Println("Done!")
}
```
</Examples>

<Pitfalls>
### 1. Копирование мьютекса

```go
type Counter struct {
    mu    sync.Mutex
    value int
}

// ❌ НЕПРАВИЛЬНО — копирование структуры с мьютексом
func process(c Counter) {
    c.mu.Lock()  // Блокируем копию!
    c.value++
    c.mu.Unlock()
}

// ✅ ПРАВИЛЬНО — указатель
func process(c *Counter) {
    c.mu.Lock()
    c.value++
    c.mu.Unlock()
}
```

### 2. Unlock без Lock

```go
var mu sync.Mutex

// ❌ PANIC
mu.Unlock()  // fatal error: sync: unlock of unlocked mutex

// ✅ Всегда парные операции
mu.Lock()
// работа
mu.Unlock()
```

### 3. Deadlock — рекурсивная блокировка

```go
var mu sync.Mutex

func outer() {
    mu.Lock()
    defer mu.Unlock()
    inner()  // ❌ DEADLOCK
}

func inner() {
    mu.Lock()  // Пытаемся заблокировать уже заблокированный
    defer mu.Unlock()
}

// ✅ Решение: отдельные внутренние функции без блокировки
func outer() {
    mu.Lock()
    defer mu.Unlock()
    innerLocked()
}

func innerLocked() {
    // работа без блокировки
}
```

### 4. Забыли Unlock

```go
func process() {
    mu.Lock()
    
    if err != nil {
        return  // ❌ Unlock не вызван!
    }
    
    mu.Unlock()
}

// ✅ Используйте defer
func process() {
    mu.Lock()
    defer mu.Unlock()
    
    if err != nil {
        return  // Unlock вызовется автоматически
    }
}
```

### 5. Слишком большая критическая секция

```go
// ❌ Блокируем слишком много
func process() {
    mu.Lock()
    defer mu.Unlock()
    
    result := heavyComputation()  // Долгая операция под блокировкой
    data[key] = result
}

// ✅ Минимизируем критическую секцию
func process() {
    result := heavyComputation()  // Вне блокировки
    
    mu.Lock()
    data[key] = result  // Только доступ к данным
    mu.Unlock()
}
```
</Pitfalls>

<Task id="1" points="5">
<Title>Задание 1: sort.Ints</Title>
<Prompt>
Отсортируйте срез int.
</Prompt>
<StarterCode>
```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    nums := []int{3, 1, 5, 2, 8}
    sort.Ints(nums)
    fmt.Println("Отсортировано:", nums)
}
```
</StarterCode>
<ExpectedOutput>
Отсортировано: [1 2 3 5 8]
</ExpectedOutput>
</Task>

<Task id="2" points="5">
<Title>Задание 2: sort.Strings</Title>
<Prompt>
Отсортируйте срез строк.
</Prompt>
<StarterCode>
```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    words := []string{"banana", "cherry", "apple"}
    sort.Strings(words)
    fmt.Println("Отсортировано:", words)
}
```
</StarterCode>
<ExpectedOutput>
Отсортировано: [apple banana cherry]
</ExpectedOutput>
</Task>

<Task id="3" points="15">
<Title>Задание 3: sort.Slice</Title>
<Prompt>
Отсортируйте срез по произвольному критерию.
</Prompt>
<StarterCode>
```go
package main

import "fmt"

// TODO: Реализуйте решение согласно заданию

func main() {
    // Ваш код здесь
    
}
```
</StarterCode>
<ExpectedOutput>
По возрасту: [{Alice 25} {Bob 30} {Charlie 20}]
</ExpectedOutput>
</Task>

<Task id="4" points="15">
<Title>Задание 4: sort.Search</Title>
<Prompt>
Найдите элемент бинарным поиском.
</Prompt>
<StarterCode>
```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    nums := []int{1, 3, 5, 7, 9}
    idx := sort.Search(len(nums), func(i int) bool {
        return nums[i] >= 5
    })
    fmt.Println("Индекс 5:", idx)
}
```
</StarterCode>
<ExpectedOutput>
Индекс 5: 2
</ExpectedOutput>
</Task>

<Task id="5" points="20">
<Title>Задание 5: sort.Interface</Title>
<Prompt>
Реализуйте sort.Interface для своего типа.
</Prompt>
<StarterCode>
```go
package main

import "fmt"

// TODO: Определите и реализуйте интерфейс

func main() {
    // Ваш код здесь
    
}
```
</StarterCode>
<ExpectedOutput>
Отсортировано: [a bb ccc]
</ExpectedOutput>
</Task>
