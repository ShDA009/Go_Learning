# Массивы

<Meta>
reading_time: 9
</Meta>

<Overview>
- **Массив** — фиксированная последовательность элементов одного типа
- Размер массива — **часть типа** (`[3]int` ≠ `[4]int`)
- Индексация с **нуля**: первый элемент — `arr[0]`
- При присвоении массив **копируется** целиком (не ссылка!)
- Для динамических коллекций используйте **срезы** (slices)

### Когда использовать массивы?

| Массив | Срез (slice) |
|--------|--------------|
| Размер известен заранее | Размер может меняться |
| Нужна копия при передаче | Нужна ссылка на данные |
| Константный размер в типе | Гибкий размер |
| Редко используется | Чаще используется |
</Overview>

<Theory>
### Что такое массив?

**Массив** — это последовательность элементов **одного типа** с **фиксированным размером**. Элементы хранятся в памяти последовательно.

```
Массив [5]int:
┌────┬────┬────┬────┬────┐
│ 10 │ 20 │ 30 │ 40 │ 50 │
└────┴────┴────┴────┴────┘
  [0]  [1]  [2]  [3]  [4]   ← индексы
```

### Размер — часть типа

В Go размер массива — это часть его типа. Это значит:
- `[3]int` и `[4]int` — **разные типы**
- Нельзя присвоить `[3]int` переменной типа `[4]int`

```go
var a [3]int
var b [4]int
a = b  // ОШИБКА! Разные типы
```

### Индексация с нуля

Первый элемент имеет индекс **0**, последний — **len-1**:

```go
arr := [3]string{"a", "b", "c"}
arr[0]  // "a" — первый
arr[1]  // "b" — второй
arr[2]  // "c" — третий (последний)
arr[3]  // ПАНИКА! Выход за границы
```

### Нулевые значения

При создании массива без инициализации все элементы получают **нулевые значения**:

```go
var nums [5]int      // [0, 0, 0, 0, 0]
var strs [3]string   // ["", "", ""]
var bools [2]bool    // [false, false]
```

### Копирование массивов

При присваивании массив **копируется целиком**:

```go
a := [3]int{1, 2, 3}
b := a       // b — КОПИЯ a
b[0] = 100   // изменяем b
fmt.Println(a[0])  // 1 (a не изменился!)
```

Это отличается от большинства языков, где массивы — ссылки.

### Сравнение массивов

Массивы одного типа можно сравнивать с помощью `==`:

```go
a := [3]int{1, 2, 3}
b := [3]int{1, 2, 3}
c := [3]int{1, 2, 4}

a == b  // true
a == c  // false
```

### Почему массивы редко используются?

Из-за фиксированного размера и копирования массивы неудобны:

```go
func processArray(arr [5]int) {  // Только массив из 5 элементов!
    // arr — копия, изменения не влияют на оригинал
}
```

Поэтому в Go чаще используют **срезы (slices)** — гибкие "представления" массивов. О них — в следующих уроках.

### Когда использовать массивы?

- Размер известен на этапе компиляции и никогда не изменится
- Нужна копия при передаче в функцию
- Фиксированные структуры: RGB (3 байта), координаты (x, y, z)
</Theory>

<Syntax>
### Объявление массива
```go
var arr [размер]тип                    // без инициализации
var arr [размер]тип = [размер]тип{...} // с инициализацией
arr := [размер]тип{...}                // краткая форма
arr := [...]тип{...}                   // размер по количеству элементов
```

### Доступ к элементам
```go
arr[0]      // первый элемент
arr[len(arr)-1]  // последний элемент
```

### Многомерные массивы
```go
var matrix [строки][столбцы]тип
```
</Syntax>

<Examples>
кода

### Пример 1: Создание массива
```go
package main

import "fmt"

func main() {
    // Без инициализации (zero values)
    var nums [5]int
    fmt.Println("Пустой:", nums)  // [0 0 0 0 0]
    
    // С инициализацией
    var colors [3]string = [3]string{"red", "green", "blue"}
    fmt.Println("Цвета:", colors)
    
    // Краткая форма
    primes := [5]int{2, 3, 5, 7, 11}
    fmt.Println("Простые:", primes)
    
    // Автоопределение размера
    fibonacci := [...]int{1, 1, 2, 3, 5, 8, 13}
    fmt.Println("Фибоначчи:", fibonacci)
    fmt.Println("Длина:", len(fibonacci))  // 7
}
```

### Пример 2: Доступ по индексу
```go
package main

import "fmt"

func main() {
    fruits := [4]string{"apple", "banana", "cherry", "date"}
    
    // Чтение
    fmt.Println("Первый:", fruits[0])   // apple
    fmt.Println("Третий:", fruits[2])   // cherry
    fmt.Println("Последний:", fruits[len(fruits)-1])  // date
    
    // Изменение
    fruits[1] = "blueberry"
    fmt.Println("После изменения:", fruits)
}
```

### Пример 3: Частичная инициализация
```go
package main

import "fmt"

func main() {
    // Часть элементов
    nums := [5]int{1, 2}  // остальные = 0
    fmt.Println(nums)  // [1 2 0 0 0]
    
    // Инициализация по индексам
    indexed := [5]int{0: 10, 2: 30, 4: 50}
    fmt.Println(indexed)  // [10 0 30 0 50]
    
    // Комбинация
    mixed := [5]int{1, 2, 4: 100}
    fmt.Println(mixed)  // [1 2 0 0 100]
}
```

### Пример 4: Перебор массива
```go
package main

import "fmt"

func main() {
    nums := [5]int{10, 20, 30, 40, 50}
    
    // Способ 1: классический for
    fmt.Println("Классический for:")
    for i := 0; i < len(nums); i++ {
        fmt.Printf("  nums[%d] = %d\n", i, nums[i])
    }
    
    // Способ 2: for range (рекомендуется)
    fmt.Println("\nFor range:")
    for index, value := range nums {
        fmt.Printf("  nums[%d] = %d\n", index, value)
    }
    
    // Способ 3: только значения
    fmt.Println("\nТолько значения:")
    for _, value := range nums {
        fmt.Print(value, " ")
    }
    
    // Способ 4: только индексы
    fmt.Println("\n\nТолько индексы:")
    for index := range nums {
        fmt.Print(index, " ")
    }
}
```

### Пример 5: Многомерные массивы
```go
package main

import "fmt"

func main() {
    // 2D массив (матрица 3x3)
    matrix := [3][3]int{
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9},
    }
    
    fmt.Println("Матрица:")
    for i := 0; i < 3; i++ {
        for j := 0; j < 3; j++ {
            fmt.Printf("%d ", matrix[i][j])
        }
        fmt.Println()
    }
    
    // Доступ к элементу
    fmt.Println("\nЭлемент [1][2]:", matrix[1][2])  // 6
    
    // Изменение строки
    matrix[0] = [3]int{10, 20, 30}
    fmt.Println("\nПосле изменения:", matrix[0])
}
```

### Пример 6: Копирование массивов
```go
package main

import "fmt"

func main() {
    original := [3]int{1, 2, 3}
    
    // Копия (не ссылка!)
    copy := original
    
    // Изменяем копию
    copy[0] = 100
    
    fmt.Println("Оригинал:", original)  // [1 2 3]
    fmt.Println("Копия:", copy)         // [100 2 3]
}
```

### Пример 7: Сравнение массивов
```go
package main

import "fmt"

func main() {
    a := [3]int{1, 2, 3}
    b := [3]int{1, 2, 3}
    c := [3]int{1, 2, 4}
    
    fmt.Println("a == b:", a == b)  // true
    fmt.Println("a == c:", a == c)  // false
    
    // Массивы разного размера нельзя сравнивать!
    // d := [4]int{1, 2, 3, 4}
    // fmt.Println(a == d)  // ошибка компиляции
}
```

### Пример 8: Практические примеры
```go
package main

import "fmt"

func main() {
    // Поиск максимума
    nums := [7]int{3, 7, 2, 9, 4, 1, 8}
    max := nums[0]
    for _, v := range nums {
        if v > max {
            max = v
        }
    }
    fmt.Println("Максимум:", max)  // 9
    
    // Сумма элементов
    sum := 0
    for _, v := range nums {
        sum += v
    }
    fmt.Println("Сумма:", sum)  // 34
    
    // Реверс массива
    arr := [5]int{1, 2, 3, 4, 5}
    for i, j := 0, len(arr)-1; i < j; i, j = i+1, j-1 {
        arr[i], arr[j] = arr[j], arr[i]
    }
    fmt.Println("Реверс:", arr)  // [5 4 3 2 1]
}
```
</Examples>

<Pitfalls>
### 1. Выход за границы массива
```go
// ❌ Паника во время выполнения
arr := [3]int{1, 2, 3}
fmt.Println(arr[3])  // panic: index out of range [3]
fmt.Println(arr[-1]) // ошибка компиляции

// ✅ Проверяйте индексы
if idx < len(arr) {
    fmt.Println(arr[idx])
}
```

### 2. Разные типы массивов
```go
// ❌ Неправильно — массивы разного размера = разные типы
var a [3]int
var b [4]int
a = b  // cannot use b (type [4]int) as type [3]int

// ✅ Массивы одного размера и типа совместимы
var c [3]int
a = c  // OK
```

### 3. Ожидание ссылки при передаче
```go
// ❌ Массив копируется, оригинал не меняется
func double(arr [3]int) {
    arr[0] *= 2  // меняем копию!
}

func main() {
    nums := [3]int{1, 2, 3}
    double(nums)
    fmt.Println(nums)  // [1 2 3] — не изменился!
}

// ✅ Используйте указатель или срез
func doublePtr(arr *[3]int) {
    arr[0] *= 2
}

func doubleSlice(arr []int) {
    arr[0] *= 2
}
```

### 4. Размер должен быть константой
```go
// ❌ Неправильно — размер должен быть константой
n := 5
var arr [n]int  // non-constant array bound n

// ✅ Правильно
const size = 5
var arr [size]int

// Или используйте срезы для динамического размера
arr := make([]int, n)
```

### 5. Забыли запятую в многострочном объявлении
```go
// ❌ Неправильно
matrix := [3][3]int{
    {1, 2, 3}   // нужна запятая!
    {4, 5, 6}
    {7, 8, 9}
}

// ✅ Правильно
matrix := [3][3]int{
    {1, 2, 3},
    {4, 5, 6},
    {7, 8, 9},  // запятая после последнего элемента — хорошая практика
}
```
</Pitfalls>

<Task id="1" points="5">
<Title>Задание 1: Создание и инициализация массива</Title>
<Prompt>
Создайте массив из 5 целых чисел и выведите его содержимое и длину.
</Prompt>
<Hints>
- Синтаксис: `arr := [5]int{10, 20, 30, 40, 50}`
- Индексы начинаются с 0
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    // Создайте массив [5]int
}
```
</StarterCode>
<ExpectedOutput>
Массив: [10 20 30 40 50]
Длина: 5
Первый элемент: 10
Последний элемент: 50
</ExpectedOutput>
</Task>

<Task id="2" points="10">
<Title>Задание 2: Автоматический размер [...]</Title>
<Prompt>
Используйте `[...]` для автоматического определения размера массива при инициализации.
</Prompt>
<Hints>
- `[...]` позволяет компилятору посчитать элементы
- Размер массива всё равно фиксирован
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    // Создайте массив с [...]
    days := [...]string{"Пн", "Вт", "Ср", "Чт", "Пт"}
}
```
</StarterCode>
<ExpectedOutput>
Дни: [Пн Вт Ср Чт Пт]
Количество дней: 5
</ExpectedOutput>
</Task>

<Task id="3" points="10">
<Title>Задание 3: Перебор массива с range</Title>
<Prompt>
Используйте `range` для перебора массива с индексами и значениями. Выведите каждый элемент с его индексом.
</Prompt>
<Hints>
- Синтаксис: `for i, v := range arr { ... }`
- i — индекс, v — значение
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    arr := [4]string{"A", "B", "C", "D"}
    fmt.Println("Перебор массива:")
    // Используйте range
}
```
</StarterCode>
<ExpectedOutput>
Перебор массива:
[0] = A
[1] = B
[2] = C
[3] = D
</ExpectedOutput>
</Task>

<Task id="4" points="15">
<Title>Задание 4: Модификация элементов</Title>
<Prompt>
Создайте массив чисел, затем удвойте каждый элемент. Покажите массив до и после изменения.
</Prompt>
<Hints>
- Изменяйте через индекс: `arr[i] = arr[i] * 2`
- Или `arr[i] *= 2`
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    arr := [5]int{1, 2, 3, 4, 5}
    fmt.Println("До:", arr)
    // Удвойте каждый элемент
}
```
</StarterCode>
<ExpectedOutput>
До: [1 2 3 4 5]
После удвоения: [2 4 6 8 10]
</ExpectedOutput>
</Task>

<Task id="5" points="15">
<Title>Задание 5: Сумма и среднее массива</Title>
<Prompt>
Вычислите сумму всех элементов массива и среднее арифметическое.
</Prompt>
<Hints>
- Для среднего преобразуйте в float64
- Среднее = сумма / количество элементов
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    arr := [5]int{10, 20, 30, 40, 50}
    fmt.Println("Массив:", arr)
    // Вычислите сумму и среднее
}
```
</StarterCode>
<ExpectedOutput>
Массив: [10 20 30 40 50]
Сумма элементов: 150
Среднее значение: 30.0
</ExpectedOutput>
</Task>
