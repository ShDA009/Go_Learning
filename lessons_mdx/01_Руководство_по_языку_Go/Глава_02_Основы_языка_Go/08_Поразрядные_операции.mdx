# Поразрядные операции

<Meta>
reading_time: 12
</Meta>

<Overview>
- Поразрядные (битовые) операции работают с **отдельными битами** чисел
- Применяются для: флагов, масок, оптимизаций, криптографии, работы с железом
- Операции сдвига: `<<` (влево), `>>` (вправо) — умножение/деление на степени 2
- Логические: `&` (AND), `|` (OR), `^` (XOR), `&^` (AND NOT)
- Работают **только с целыми числами**

### Таблица битовых операций

| Операция | Символ | Описание | Пример |
|----------|--------|----------|--------|
| AND | `&` | 1 если оба бита = 1 | `5 & 3 = 1` |
| OR | `\|` | 1 если хотя бы один = 1 | `5 \| 3 = 7` |
| XOR | `^` | 1 если биты разные | `5 ^ 3 = 6` |
| AND NOT | `&^` | Сброс битов | `5 &^ 3 = 4` |
| Сдвиг влево | `<<` | Умножение на 2ⁿ | `5 << 1 = 10` |
| Сдвиг вправо | `>>` | Деление на 2ⁿ | `5 >> 1 = 2` |
</Overview>

<Theory>
### Что такое биты?

Компьютер хранит всё в **двоичном формате** — последовательности 0 и 1 (битов). Число 5 в двоичном виде: `101` (4 + 0 + 1).

```
Десятичное    Двоичное
    1            001
    2            010
    3            011
    4            100
    5            101
    6            110
    7            111
```

Поразрядные операции работают с каждым битом отдельно.

### Операция AND (&)

Результат = 1 только если **оба** бита = 1:

```
  5: 101
& 3: 011
------
  1: 001
```

Применение: **маскирование** — извлечение определённых битов.

### Операция OR (|)

Результат = 1 если **хотя бы один** бит = 1:

```
  5: 101
| 3: 011
------
  7: 111
```

Применение: **объединение флагов**.

### Операция XOR (^)

Результат = 1 если биты **разные**:

```
  5: 101
^ 3: 011
------
  6: 110
```

Применение: **переключение битов**, криптография, обмен значений без временной переменной.

### Операции сдвига

**Сдвиг влево (<<)** — умножение на 2^n:
```go
5 << 1   // 5 * 2 = 10
5 << 2   // 5 * 4 = 20
1 << 10  // 1 * 1024 = 1024 (1 KB)
```

**Сдвиг вправо (>>)** — деление на 2^n:
```go
10 >> 1  // 10 / 2 = 5
20 >> 2  // 20 / 4 = 5
```

### Практические применения

**1. Флаги и права доступа:**
```go
const (
    Read    = 1 << 0  // 001 = 1
    Write   = 1 << 1  // 010 = 2
    Execute = 1 << 2  // 100 = 4
)

permissions := Read | Write  // 011 = 3
canRead := permissions & Read != 0  // true
```

**2. Быстрое умножение/деление на степени 2:**
```go
x * 8  ==  x << 3   // быстрее
x / 4  ==  x >> 2   // быстрее
```

**3. Проверка чётности:**
```go
isEven := n & 1 == 0  // чётное если последний бит = 0
```

**4. Обмен значений без временной переменной:**
```go
a = a ^ b
b = a ^ b
a = a ^ b
```

### Когда использовать?

- Работа с флагами и правами
- Оптимизация критичного кода
- Работа с протоколами и железом
- Криптография

В обычном коде используйте с осторожностью — читаемость важнее микрооптимизаций.
</Theory>

<Syntax>
### Логические битовые операции
```go
a & b    // AND: бит = 1 если оба = 1
a | b    // OR: бит = 1 если хотя бы один = 1
a ^ b    // XOR: бит = 1 если биты разные
a &^ b   // AND NOT: сбросить в a биты, которые = 1 в b
```

### Операции сдвига
```go
a << n   // сдвиг влево на n бит (умножение на 2^n)
a >> n   // сдвиг вправо на n бит (деление на 2^n)
```

### Унарная инверсия
```go
^a       // инверсия всех битов (NOT)
```
</Syntax>

<Examples>
кода

### Пример 1: Визуализация битов
```go
package main

import "fmt"

func main() {
    a := 5  // 101 в двоичной
    b := 3  // 011 в двоичной
    
    fmt.Printf("a = %d = %08b\n", a, a)
    fmt.Printf("b = %d = %08b\n", b, b)
    
    fmt.Printf("\na & b  = %d = %08b (AND)\n", a&b, a&b)
    fmt.Printf("a | b  = %d = %08b (OR)\n", a|b, a|b)
    fmt.Printf("a ^ b  = %d = %08b (XOR)\n", a^b, a^b)
    fmt.Printf("a &^ b = %d = %08b (AND NOT)\n", a&^b, a&^b)
}
```

**Вывод:**
```
a = 5 = 00000101
b = 3 = 00000011

a & b  = 1 = 00000001 (AND)
a | b  = 7 = 00000111 (OR)
a ^ b  = 6 = 00000110 (XOR)
a &^ b = 4 = 00000100 (AND NOT)
```

### Пример 2: Операции сдвига
```go
package main

import "fmt"

func main() {
    a := 1
    
    fmt.Println("=== Сдвиг влево (умножение на 2^n) ===")
    fmt.Printf("%d << 0 = %d (%08b)\n", a, a<<0, a<<0)  // 1
    fmt.Printf("%d << 1 = %d (%08b)\n", a, a<<1, a<<1)  // 2
    fmt.Printf("%d << 2 = %d (%08b)\n", a, a<<2, a<<2)  // 4
    fmt.Printf("%d << 3 = %d (%08b)\n", a, a<<3, a<<3)  // 8
    
    b := 16
    fmt.Println("\n=== Сдвиг вправо (деление на 2^n) ===")
    fmt.Printf("%d >> 0 = %d\n", b, b>>0)  // 16
    fmt.Printf("%d >> 1 = %d\n", b, b>>1)  // 8
    fmt.Printf("%d >> 2 = %d\n", b, b>>2)  // 4
    fmt.Printf("%d >> 3 = %d\n", b, b>>3)  // 2
    fmt.Printf("%d >> 4 = %d\n", b, b>>4)  // 1
}
```

### Пример 3: Битовые флаги
```go
package main

import "fmt"

// Права доступа как битовые флаги
const (
    Read    = 1 << iota  // 001 = 1
    Write                // 010 = 2
    Execute              // 100 = 4
)

func main() {
    // Установка прав
    permissions := Read | Write  // 011 = 3
    
    fmt.Printf("Права: %03b (%d)\n", permissions, permissions)
    
    // Проверка прав
    hasRead := permissions & Read != 0
    hasWrite := permissions & Write != 0
    hasExecute := permissions & Execute != 0
    
    fmt.Println("Read:", hasRead)      // true
    fmt.Println("Write:", hasWrite)    // true
    fmt.Println("Execute:", hasExecute) // false
    
    // Добавление права
    permissions |= Execute  // 111 = 7
    fmt.Printf("После добавления Execute: %03b\n", permissions)
    
    // Удаление права
    permissions &^= Write  // 101 = 5
    fmt.Printf("После удаления Write: %03b\n", permissions)
    
    // Переключение права (toggle)
    permissions ^= Read  // 100 = 4
    fmt.Printf("После toggle Read: %03b\n", permissions)
}
```

### Пример 4: Проверка чётности через биты
```go
package main

import "fmt"

func main() {
    // Последний бит чётного числа всегда 0
    for i := 0; i < 10; i++ {
        isEven := i & 1 == 0  // быстрее чем i % 2 == 0
        fmt.Printf("%d: %08b — %s\n", i, i, 
                   map[bool]string{true: "чётное", false: "нечётное"}[isEven])
    }
}
```

### Пример 5: Умножение и деление на степени двойки
```go
package main

import "fmt"

func main() {
    x := 10
    
    // Умножение на 2, 4, 8...
    fmt.Printf("%d * 2 = %d (сдвиг: %d)\n", x, x*2, x<<1)
    fmt.Printf("%d * 4 = %d (сдвиг: %d)\n", x, x*4, x<<2)
    fmt.Printf("%d * 8 = %d (сдвиг: %d)\n", x, x*8, x<<3)
    
    // Деление на 2, 4, 8...
    y := 80
    fmt.Printf("%d / 2 = %d (сдвиг: %d)\n", y, y/2, y>>1)
    fmt.Printf("%d / 4 = %d (сдвиг: %d)\n", y, y/4, y>>2)
    fmt.Printf("%d / 8 = %d (сдвиг: %d)\n", y, y/8, y>>3)
}
```

### Пример 6: Маска для извлечения битов
```go
package main

import "fmt"

func main() {
    // Цвет в формате RGB (0xRRGGBB)
    color := 0xFF5733  // оранжевый
    
    // Извлечение компонентов
    red := (color >> 16) & 0xFF    // сдвиг на 16, маска 8 бит
    green := (color >> 8) & 0xFF   // сдвиг на 8, маска 8 бит
    blue := color & 0xFF           // маска 8 бит
    
    fmt.Printf("Цвет: #%06X\n", color)
    fmt.Printf("Red:   %d (0x%02X)\n", red, red)
    fmt.Printf("Green: %d (0x%02X)\n", green, green)
    fmt.Printf("Blue:  %d (0x%02X)\n", blue, blue)
}
```

### Пример 7: XOR для шифрования
```go
package main

import "fmt"

func main() {
    message := "Hello"
    key := byte(42)  // простой ключ
    
    // Шифрование XOR
    encrypted := make([]byte, len(message))
    for i := 0; i < len(message); i++ {
        encrypted[i] = message[i] ^ key
    }
    fmt.Printf("Зашифровано: %v\n", encrypted)
    
    // Дешифрование (тот же XOR!)
    decrypted := make([]byte, len(encrypted))
    for i := 0; i < len(encrypted); i++ {
        decrypted[i] = encrypted[i] ^ key
    }
    fmt.Printf("Расшифровано: %s\n", decrypted)
}
```

### Пример 8: Подсчёт единичных битов
```go
package main

import "fmt"

func countBits(n int) int {
    count := 0
    for n != 0 {
        count += n & 1  // добавляем младший бит
        n >>= 1         // сдвигаем вправо
    }
    return count
}

func main() {
    nums := []int{0, 1, 7, 15, 16, 255}
    
    for _, n := range nums {
        fmt.Printf("%3d = %08b, единиц: %d\n", n, n, countBits(n))
    }
}
```
</Examples>

<Pitfalls>
### 1. Путаница & и &&
```go
// ❌ Неправильно — & это битовый AND, не логический
if x & y {  // non-bool x & y used as condition
    // ...
}

// ✅ Правильно
if x&y != 0 {  // битовая проверка
    // ...
}
// или
if x > 0 && y > 0 {  // логический AND
    // ...
}
```

### 2. Сдвиг отрицательных чисел
```go
// ⚠️ Осторожно — поведение зависит от знака
var a int8 = -4
b := a >> 1  // арифметический сдвиг, сохраняет знак
fmt.Println(b)  // -2

var c uint8 = 252  // это -4 в int8
d := c >> 1  // логический сдвиг
fmt.Println(d)  // 126
```

### 3. Переполнение при сдвиге
```go
// ❌ Сдвиг за пределы типа
var a int8 = 1
b := a << 7   // 128 — переполнение для int8!
fmt.Println(b)  // -128

// ✅ Используйте больший тип
var c int = 1
d := c << 7  // 128 — OK
```

### 4. Приоритет операций
```go
// ❌ Неожиданный результат
x := 5
result := x & 1 == 0  // это x & (1 == 0) = x & false — ошибка!

// ✅ Правильно — скобки для ясности
result := (x & 1) == 0
```

### 5. Битовые операции с разными типами
```go
// ❌ Неправильно
var a int32 = 5
var b int64 = 3
c := a & b  // invalid operation: mismatched types

// ✅ Правильно — приведение типа
c := int64(a) & b
```
</Pitfalls>

<Task id="1" points="10">
<Title>Задание 1: Побитовое И (&)</Title>
<Prompt>
Выполните побитовое И для двух чисел и объясните результат с помощью двоичного представления.
</Prompt>
<Hints>
- Побитовое И: 1 & 1 = 1, иначе 0
- Для вывода в двоичном формате: %b
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    a, b := 12, 10
    // Покажите побитовое И
}
```
</StarterCode>
<ExpectedOutput>
a = 12 (двоичное: 1100)
b = 10 (двоичное: 1010)
a & b = 8 (двоичное: 1000)
</ExpectedOutput>
</Task>

<Task id="2" points="10">
<Title>Задание 2: Побитовое ИЛИ (|)</Title>
<Prompt>
Выполните побитовое ИЛИ и покажите, как оно объединяет биты двух чисел.
</Prompt>
<Hints>
- Побитовое ИЛИ: 0 | 0 = 0, иначе 1
- Результат содержит биты, установленные хотя бы в одном числе
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    a, b := 12, 10
    // Покажите побитовое ИЛИ
}
```
</StarterCode>
<ExpectedOutput>
a = 12 (двоичное: 1100)
b = 10 (двоичное: 1010)
a | b = 14 (двоичное: 1110)
</ExpectedOutput>
</Task>

<Task id="3" points="15">
<Title>Задание 3: Исключающее ИЛИ (XOR, ^)</Title>
<Prompt>
Продемонстрируйте XOR и его свойство: a ^ a = 0, a ^ 0 = a.
</Prompt>
<Hints>
- XOR: одинаковые биты → 0, разные биты → 1
- XOR используется для шифрования и обмена значений
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    // Покажите XOR и его свойства
}
```
</StarterCode>
<ExpectedOutput>
12 ^ 10 = 6 (двоичное: 0110)
42 ^ 42 = 0 (любое число XOR само с собой = 0)
42 ^ 0 = 42 (любое число XOR 0 = само число)
</ExpectedOutput>
</Task>

<Task id="4" points="15">
<Title>Задание 4: Сдвиги битов (<< и >>)</Title>
<Prompt>
Продемонстрируйте сдвиг битов влево (умножение на степень 2) и вправо (деление на степень 2).
</Prompt>
<Hints>
- `<< n` эквивалентно умножению на 2^n
- `>> n` эквивалентно делению на 2^n
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    // Покажите сдвиги влево и вправо
}
```
</StarterCode>
<ExpectedOutput>
1 << 0 = 1
1 << 1 = 2
1 << 2 = 4
1 << 3 = 8

16 >> 1 = 8
16 >> 2 = 4
16 >> 3 = 2
</ExpectedOutput>
</Task>

<Task id="5" points="20">
<Title>Задание 5: Проверка установленного бита</Title>
<Prompt>
Создайте функцию проверки, установлен ли определённый бит в числе. Проверьте биты числа 13 (1101).
</Prompt>
<Hints>
- Проверка бита n: `(число & (1 << n)) != 0`
- Бит 0 — самый младший (справа)
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    n := 13  // 1101 в двоичной
    fmt.Printf("Число %d = %b в двоичной системе\n", n, n)
    // Проверьте каждый бит
}
```
</StarterCode>
<ExpectedOutput>
Число 13 = 1101 в двоичной системе
Бит 0 установлен: true
Бит 1 установлен: false
Бит 2 установлен: true
Бит 3 установлен: true
</ExpectedOutput>
</Task>
