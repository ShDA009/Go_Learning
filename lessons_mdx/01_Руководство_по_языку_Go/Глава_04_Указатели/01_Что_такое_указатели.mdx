# Указатели в Go

<Meta>
reading_time: 9
</Meta>

<Overview>
1. **Указатель** — это переменная, которая хранит адрес другой переменной в памяти
2. **Адрес памяти** — уникальный идентификатор местоположения данных (шестнадцатеричное число)
3. **Разыменование** — получение значения по адресу через оператор `*`
4. **Оператор &** — получение адреса переменной
5. **nil** — нулевое значение указателя (не указывает ни на что)
6. **Типизация указателей** — указатель должен соответствовать типу данных, на которые указывает
7. **Функция new()** — создаёт безымянный объект и возвращает указатель на него
</Overview>

<Theory>
### Что такое указатель?

**Указатель** — это переменная, которая хранит не значение, а **адрес** другой переменной в памяти.

Представьте память как огромную таблицу с пронумерованными ячейками:
```
Адрес     Значение    Переменная
0x0001    42          x
0x0002    0x0001      p (указатель на x)
```

Переменная `p` хранит не число, а "координаты" переменной `x` в памяти.

### Зачем нужны указатели?

1. **Изменять данные внутри функций** — по умолчанию Go копирует аргументы
2. **Экономить память** — не копировать большие структуры
3. **Работать с данными, которые могут отсутствовать** — nil как "нет значения"
4. **Создавать связанные структуры** — списки, деревья, графы

### Операторы & и *

**& (амперсанд)** — получить адрес:
```go
x := 42
p := &x  // p содержит адрес x
```

** (звёздочка)** — разыменование (получить значение по адресу):
```go
value := *p  // value = 42 (значение по адресу)
*p = 100     // изменяем x через указатель, x теперь 100
```

### Типизация указателей

Указатель имеет тип. `*int` — указатель на int, `*string` — на string:

```go
var x int = 42
var p *int = &x    // OK

var s string = "hello"
p = &s  // ОШИБКА! *int не совместим с *string
```

### nil — нулевой указатель

`nil` означает "указатель ни на что не указывает":

```go
var p *int  // p = nil

if p != nil {
    fmt.Println(*p)  // безопасно
} else {
    fmt.Println("p is nil")
}

// *p при p == nil вызовет PANIC!
```

**Всегда проверяйте указатели на nil перед разыменованием!**

### new() vs &

Оба способа создают указатель:

```go
// Способ 1: через переменную
x := 42
p1 := &x

// Способ 2: через new()
p2 := new(int)  // создаёт int = 0, возвращает *int
*p2 = 42
```

`new(T)` создаёт переменную типа T с нулевым значением и возвращает указатель.

### Указатели на указатели

Да, так можно:
```go
x := 42
p := &x   // *int
pp := &p  // **int (указатель на указатель)

**pp = 100  // x теперь 100
```

Редко нужно, но иногда полезно.
</Theory>

<Syntax>
### Объявление указателя

```go
var p *int          // указатель на int (значение nil)
var ps *string      // указатель на string
var pf *float64     // указатель на float64
```

### Получение адреса переменной

```go
x := 10
p := &x             // p содержит адрес переменной x
```

### Разыменование указателя

```go
value := *p         // получение значения по адресу
*p = 20             // изменение значения по адресу
```

### Создание объекта через new()

```go
p := new(int)       // создаёт int со значением 0, возвращает *int
*p = 42             // присваиваем значение
```

### Указатель на указатель

```go
var pp **int        // указатель на указатель на int
pp = &p             // присваиваем адрес указателя
**pp = 100          // доступ к значению через двойное разыменование
```

### Массив указателей

```go
var arr [3]*int     // массив из 3 указателей на int
arr[0] = &x
```
</Syntax>

<Examples>
кода

### Базовая работа с указателями

```go
package main

import "fmt"

func main() {
    // Создаём переменную
    x := 42
    
    // Создаём указатель на переменную
    p := &x
    
    // Выводим информацию
    fmt.Println("Значение x:", x)           // 42
    fmt.Println("Адрес x:", p)              // 0xc000018098 (примерно)
    fmt.Println("Значение по адресу:", *p)  // 42
    
    // Изменяем значение через указатель
    *p = 100
    fmt.Println("Новое значение x:", x)     // 100
}
```

### Проверка на nil

```go
package main

import "fmt"

func main() {
    var p *int  // nil по умолчанию
    
    // Безопасная проверка перед разыменованием
    if p != nil {
        fmt.Println("Значение:", *p)
    } else {
        fmt.Println("Указатель равен nil")
    }
    
    // Присваиваем адрес
    x := 5
    p = &x
    
    if p != nil {
        fmt.Println("Значение:", *p)  // 5
    }
}
```

### Использование функции new()

```go
package main

import "fmt"

func main() {
    // Создаём безымянный объект int
    p := new(int)
    
    fmt.Println("Адрес:", p)        // 0xc000018098
    fmt.Println("Значение:", *p)    // 0 (значение по умолчанию)
    
    // Изменяем значение
    *p = 999
    fmt.Println("Новое значение:", *p)  // 999
    
    // Для других типов
    ps := new(string)
    fmt.Println("Строка по умолчанию:", *ps)  // "" (пустая строка)
    
    pf := new(float64)
    fmt.Println("Float по умолчанию:", *pf)   // 0
}
```

### Указатель на указатель

```go
package main

import "fmt"

func main() {
    a := 10
    
    p := &a      // указатель на a
    pp := &p     // указатель на указатель p
    
    fmt.Println("Значение a:", a)           // 10
    fmt.Println("Адрес a (p):", p)          // 0xc000018098
    fmt.Println("Адрес p (pp):", pp)        // 0xc00000e028
    
    fmt.Println("*p =", *p)                 // 10 (значение a)
    fmt.Println("*pp =", *pp)               // адрес a
    fmt.Println("**pp =", **pp)             // 10 (значение a)
    
    // Изменяем значение через указатель на указатель
    **pp = 50
    fmt.Println("Новое значение a:", a)     // 50
}
```

### Массив указателей

```go
package main

import "fmt"

func main() {
    a, b, c := 1, 2, 3
    
    // Массив указателей
    pointers := [3]*int{&a, &b, &c}
    
    // Вывод значений через указатели
    for i, p := range pointers {
        fmt.Printf("pointers[%d] = %p, значение = %d\n", i, p, *p)
    }
    
    // Изменяем значение через указатель
    *pointers[1] = 200
    fmt.Println("b =", b)  // 200
}
```

### Сравнение указателей

```go
package main

import "fmt"

func main() {
    x := 10
    y := 10
    
    p1 := &x
    p2 := &x
    p3 := &y
    
    // p1 и p2 указывают на одну переменную
    fmt.Println("p1 == p2:", p1 == p2)  // true
    
    // p1 и p3 указывают на разные переменные (хотя значения одинаковые)
    fmt.Println("p1 == p3:", p1 == p3)  // false
    
    // Сравниваем значения по указателям
    fmt.Println("*p1 == *p3:", *p1 == *p3)  // true
}
```
</Examples>

<Pitfalls>
### 1. Разыменование nil указателя

```go
// ❌ НЕПРАВИЛЬНО — panic: runtime error
var p *int
fmt.Println(*p)  // указатель nil!

// ✅ ПРАВИЛЬНО — проверка перед разыменованием
var p *int
if p != nil {
    fmt.Println(*p)
}
```

### 2. Несоответствие типов указателя и переменной

```go
// ❌ НЕПРАВИЛЬНО — ошибка компиляции
x := 10
var p *float64 = &x  // cannot use &x (type *int) as type *float64

// ✅ ПРАВИЛЬНО — типы должны совпадать
x := 10
var p *int = &x
```

### 3. Попытка получить адрес константы

```go
// ❌ НЕПРАВИЛЬНО — константы не имеют адреса
const pi = 3.14
p := &pi  // cannot take the address of pi

// ✅ ПРАВИЛЬНО — используем переменную
pi := 3.14
p := &pi
```

### 4. Путаница между объявлением и разыменованием

```go
// ❌ НЕПРАВИЛЬНО — путаница с *
var p *int    // это ОБЪЯВЛЕНИЕ указателя
*p = 10       // это РАЗЫМЕНОВАНИЕ (но p = nil!)

// ✅ ПРАВИЛЬНО
x := 10
p := &x       // p указывает на x
*p = 20       // теперь можно разыменовывать
```

### 5. Забыли про & при передаче адреса

```go
// ❌ НЕПРАВИЛЬНО
x := 10
var p *int = x  // cannot use x (type int) as type *int

// ✅ ПРАВИЛЬНО
x := 10
var p *int = &x  // используем & для получения адреса
```

### 6. Изменение копии вместо оригинала

```go
// ❌ НЕПРАВИЛЬНО — создаётся копия указателя
func wrongSwap(a, b *int) {
    a, b = b, a  // меняются только локальные копии указателей
}

// ✅ ПРАВИЛЬНО — меняем значения по указателям
func correctSwap(a, b *int) {
    *a, *b = *b, *a  // меняем значения, на которые указывают
}
```
</Pitfalls>

<Task id="1" points="5">
<Title>Задание 1: Создание указателя</Title>
<Prompt>
Создайте переменную и указатель на неё. Выведите значение и адрес.
</Prompt>
<Hints>
- & получает адрес переменной
- * разыменовывает указатель (получает значение)
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    x := 42
    // Создайте указатель и выведите информацию
}
```
</StarterCode>
<ExpectedOutput>
Значение x: 42
Адрес x: 0x... (не nil)
Значение через указатель: 42
</ExpectedOutput>
</Task>

<Task id="2" points="10">
<Title>Задание 2: Изменение через указатель</Title>
<Prompt>
Измените значение переменной через указатель. Покажите значение до и после.
</Prompt>
<Hints>
- `*p = 100` записывает 100 по адресу p
- Это изменяет исходную переменную
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    x := 10
    p := &x
    fmt.Println("До изменения: x =", x)
    // Измените через указатель
}
```
</StarterCode>
<ExpectedOutput>
До изменения: x = 10
Изменяем через указатель...
После изменения: x = 100
</ExpectedOutput>
</Task>

<Task id="3" points="10">
<Title>Задание 3: new() для создания указателя</Title>
<Prompt>
Используйте функцию `new()` для создания указателя на int. Покажите значение по умолчанию и присвойте новое.
</Prompt>
<Hints>
- `p := new(int)` создаёт *int с нулевым значением
- new() выделяет память и возвращает указатель
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    fmt.Println("Указатель через new():")
    // Создайте через new и покажите значения
}
```
</StarterCode>
<ExpectedOutput>
Указатель через new():
Значение по умолчанию: 0
После присвоения: 42
</ExpectedOutput>
</Task>

<Task id="4" points="15">
<Title>Задание 4: nil указатель</Title>
<Prompt>
Продемонстрируйте nil указатель и безопасную проверку перед разыменованием.
</Prompt>
<Hints>
- Объявление без инициализации: `var p *int` (nil)
- Всегда проверяйте nil перед разыменованием
</Hints>
<StarterCode>
```go
package main

import "fmt"

func main() {
    fmt.Println("Проверка nil указателя:")
    // Покажите работу с nil указателем
}
```
</StarterCode>
<ExpectedOutput>
Проверка nil указателя:
p == nil: true
После присвоения адреса:
p == nil: false
Значение: 10
</ExpectedOutput>
</Task>

<Task id="5" points="15">
<Title>Задание 5: Указатель на структуру</Title>
<Prompt>
Создайте структуру Person и указатель на неё. Измените поля через указатель.
</Prompt>
<Hints>
- `p := &Person{...}` создаёт указатель на структуру
- В Go не нужен -> как в C: `p.Name` работает для указателей
</Hints>
<StarterCode>
```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func main() {
    fmt.Println("Структура через указатель:")
    // Создайте указатель и измените поля
}
```
</StarterCode>
<ExpectedOutput>
Структура через указатель:
До: {Alice 25}
После: {Bob 30}
</ExpectedOutput>
</Task>
