# Буферизированный ввод-вывод (bufio)

<Meta>
reading_time: 7
</Meta>

<Overview>
1. **bufio.Writer** — буферизированная запись (накопление данных)
2. **bufio.Reader** — буферизированное чтение (предзагрузка)
3. **Flush()** — принудительная запись буфера в источник
4. **Производительность** — меньше системных вызовов
5. **Scanner** — удобное построчное чтение
6. **Размер буфера** — по умолчанию 4KB
</Overview>

<Theory>
### Зачем нужна буферизация?

Каждый вызов `Write()` на файле — это **системный вызов**. Системные вызовы дорогие!

**Без буфера:**
```go
for i := 0; i < 1000; i++ {
    file.Write([]byte("x"))  // 1000 системных вызовов!
}
```

**С буфером:**
```go
bw := bufio.NewWriter(file)
for i := 0; i < 1000; i++ {
    bw.WriteByte('x')  // пишем в память
}
bw.Flush()  // 1 системный вызов!
```

### bufio.Writer — накопление записей

```go
file, _ := os.Create("output.txt")
defer file.Close()

writer := bufio.NewWriter(file)

// Всё идёт в буфер
writer.WriteString("Line 1\n")
writer.WriteString("Line 2\n")
writer.WriteString("Line 3\n")

// НЕ ЗАБУДЬТЕ FLUSH!
writer.Flush()  // Только сейчас данные в файле!
```

### ВАЖНО: всегда вызывайте Flush!

```go
// ПЛОХО — данные потеряны!
writer := bufio.NewWriter(file)
writer.WriteString("important data")
// файл закрывается, данные в буфере — потеряны!

// ХОРОШО
writer := bufio.NewWriter(file)
defer writer.Flush()  // гарантированный сброс
writer.WriteString("important data")
```

### bufio.Reader — предзагрузка

Читает большой блок за раз, отдаёт по запросу:

```go
reader := bufio.NewReader(file)

// Эффективное чтение
for {
    line, err := reader.ReadString('\n')
    if err == io.EOF {
        break
    }
    process(line)
}
```

### bufio.Scanner — удобное построчное чтение

```go
scanner := bufio.NewScanner(file)

for scanner.Scan() {
    line := scanner.Text()  // без \n на конце
    process(line)
}

if err := scanner.Err(); err != nil {
    log.Fatal(err)
}
```

### Настройка размера буфера

```go
// По умолчанию 4KB
writer := bufio.NewWriter(file)

// Свой размер
writer := bufio.NewWriterSize(file, 64*1024)  // 64KB

// Для Scanner (максимальная длина строки)
scanner := bufio.NewScanner(file)
buf := make([]byte, 1024*1024)  // 1MB буфер
scanner.Buffer(buf, 1024*1024)
```

### Когда использовать bufio?

| Ситуация | Решение |
|----------|---------|
| Много мелких записей | `bufio.Writer` |
| Построчное чтение | `bufio.Scanner` |
| Чтение до разделителя | `bufio.Reader` |
| Один большой блок | Стандартный Read/Write |
</Theory>

<Syntax>
### Создание буферизированных потоков

```go
// Writer
writer := bufio.NewWriter(file)
writer := bufio.NewWriterSize(file, 8192)  // custom size

// Reader
reader := bufio.NewReader(file)
reader := bufio.NewReaderSize(file, 8192)  // custom size

// Scanner
scanner := bufio.NewScanner(file)
```

### Методы Writer

```go
writer.Write([]byte)       // запись байтов
writer.WriteString(string) // запись строки
writer.WriteByte(byte)     // запись байта
writer.WriteRune(rune)     // запись руны
writer.Flush()             // сброс буфера
```
</Syntax>

<Examples>
кода

### Буферизированная запись

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Create("buffered.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer file.Close()
    
    // Создаём буферизированный writer
    writer := bufio.NewWriter(file)
    
    // Записываем данные (в буфер)
    writer.WriteString("Line 1\n")
    writer.WriteString("Line 2\n")
    writer.WriteString("Line 3\n")
    
    // Проверяем размер буфера
    fmt.Println("Buffered:", writer.Buffered())
    fmt.Println("Available:", writer.Available())
    
    // ВАЖНО: сбрасываем буфер в файл
    err = writer.Flush()
    if err != nil {
        fmt.Println("Flush error:", err)
    }
    
    fmt.Println("File written!")
}
```

### Буферизированное чтение

```go
package main

import (
    "bufio"
    "fmt"
    "io"
    "os"
)

func main() {
    file, err := os.Open("buffered.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer file.Close()
    
    reader := bufio.NewReader(file)
    
    for {
        // ReadString читает до разделителя (включая его)
        line, err := reader.ReadString('\n')
        if err == io.EOF {
            break
        }
        if err != nil {
            fmt.Println("Error:", err)
            break
        }
        
        fmt.Print(line)  // строка уже содержит \n
    }
}
```

### Scanner для построчного чтения

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, err := os.Open("buffered.txt")
    if err != nil {
        fmt.Println("Error:", err)
        return
    }
    defer file.Close()
    
    scanner := bufio.NewScanner(file)
    
    lineNum := 0
    for scanner.Scan() {
        lineNum++
        fmt.Printf("%d: %s\n", lineNum, scanner.Text())
    }
    
    if err := scanner.Err(); err != nil {
        fmt.Println("Scanner error:", err)
    }
}
```

### Scanner с кастомным разделителем

```go
package main

import (
    "bufio"
    "fmt"
    "strings"
)

func main() {
    data := "word1,word2,word3,word4"
    reader := strings.NewReader(data)
    
    scanner := bufio.NewScanner(reader)
    
    // Разделитель — запятая
    scanner.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {
        for i := 0; i < len(data); i++ {
            if data[i] == ',' {
                return i + 1, data[:i], nil
            }
        }
        if atEOF && len(data) > 0 {
            return len(data), data, nil
        }
        return 0, nil, nil
    })
    
    for scanner.Scan() {
        fmt.Println("Token:", scanner.Text())
    }
}
```

### Встроенные разделители Scanner

```go
package main

import (
    "bufio"
    "fmt"
    "strings"
)

func main() {
    data := "Hello World!\nThis is Go.\nBuffered I/O."
    
    // По строкам (по умолчанию)
    fmt.Println("=== Lines ===")
    scanner := bufio.NewScanner(strings.NewReader(data))
    for scanner.Scan() {
        fmt.Println(scanner.Text())
    }
    
    // По словам
    fmt.Println("\n=== Words ===")
    scanner = bufio.NewScanner(strings.NewReader(data))
    scanner.Split(bufio.ScanWords)
    for scanner.Scan() {
        fmt.Println(scanner.Text())
    }
    
    // По байтам
    fmt.Println("\n=== Bytes (first 10) ===")
    scanner = bufio.NewScanner(strings.NewReader(data))
    scanner.Split(bufio.ScanBytes)
    count := 0
    for scanner.Scan() && count < 10 {
        fmt.Printf("%q ", scanner.Text())
        count++
    }
    fmt.Println()
    
    // По рунам (Unicode)
    fmt.Println("\n=== Runes (Привет) ===")
    scanner = bufio.NewScanner(strings.NewReader("Привет"))
    scanner.Split(bufio.ScanRunes)
    for scanner.Scan() {
        fmt.Printf("%s ", scanner.Text())
    }
    fmt.Println()
}
```

### Peek — подглядывание без потребления

```go
package main

import (
    "bufio"
    "fmt"
    "strings"
)

func main() {
    reader := bufio.NewReader(strings.NewReader("Hello, World!"))
    
    // Подглядываем первые 5 байт
    peek, _ := reader.Peek(5)
    fmt.Printf("Peek: %s\n", string(peek))
    
    // Данные всё ещё доступны
    data, _ := reader.ReadString('!')
    fmt.Printf("Read: %s\n", data)
}
```

### Эффективная запись больших данных

```go
package main

import (
    "bufio"
    "fmt"
    "os"
    "time"
)

func writeUnbuffered(filename string, lines int) time.Duration {
    file, _ := os.Create(filename)
    defer file.Close()
    
    start := time.Now()
    for i := 0; i < lines; i++ {
        file.WriteString(fmt.Sprintf("Line %d\n", i))
    }
    return time.Since(start)
}

func writeBuffered(filename string, lines int) time.Duration {
    file, _ := os.Create(filename)
    defer file.Close()
    
    writer := bufio.NewWriter(file)
    defer writer.Flush()
    
    start := time.Now()
    for i := 0; i < lines; i++ {
        writer.WriteString(fmt.Sprintf("Line %d\n", i))
    }
    return time.Since(start)
}

func main() {
    lines := 100000
    
    unbuffered := writeUnbuffered("unbuffered.txt", lines)
    buffered := writeBuffered("buffered.txt", lines)
    
    fmt.Printf("Unbuffered: %v\n", unbuffered)
    fmt.Printf("Buffered: %v\n", buffered)
    fmt.Printf("Speedup: %.2fx\n", float64(unbuffered)/float64(buffered))
    
    // Cleanup
    os.Remove("unbuffered.txt")
    os.Remove("buffered.txt")
}
```

### ReadWriter — комбинация Reader и Writer

```go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    file, _ := os.OpenFile("data.txt", 
        os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
    defer file.Close()
    
    // Комбинированный буферизированный поток
    rw := bufio.NewReadWriter(
        bufio.NewReader(file),
        bufio.NewWriter(file),
    )
    
    // Записываем
    rw.WriteString("Hello, buffered world!\n")
    rw.Flush()
    
    // Перемещаемся в начало
    file.Seek(0, 0)
    
    // Читаем
    line, _ := rw.ReadString('\n')
    fmt.Println("Read:", line)
}
```
</Examples>

<Pitfalls>
### 1. Забыли Flush()

```go
writer := bufio.NewWriter(file)
writer.WriteString("data")
// ❌ Данные остались в буфере, файл пуст!

// ✅ Всегда вызывайте Flush
defer writer.Flush()
```

### 2. Scanner с длинными строками

```go
scanner := bufio.NewScanner(file)
// ❌ По умолчанию буфер 64KB — длинные строки вызовут ошибку

// ✅ Увеличьте буфер
buf := make([]byte, 1024*1024)  // 1MB
scanner.Buffer(buf, len(buf))
```

### 3. Потеря данных при ошибке

```go
// ❌ При ошибке данные в буфере потеряются
writer.WriteString("important")
// ошибка...

// ✅ Flush перед критическими точками
writer.WriteString("important")
writer.Flush()  // гарантируем запись
```
</Pitfalls>

<Task id="1" points="10">
<Title>Задание 1: http.Cookie</Title>
<Prompt>
Создайте cookie.
</Prompt>
<StarterCode>
```go
package main

import "fmt"

func main() {
    fmt.Println("Cookie: http.SetCookie(w, &http.Cookie{Name: \"key\", Value: \"val\"})")
}
```
</StarterCode>
<ExpectedOutput>
Cookie: http.SetCookie(w, &http.Cookie{Name: "key", Value: "val"})
</ExpectedOutput>
</Task>

<Task id="2" points="10">
<Title>Задание 2: Чтение cookie</Title>
<Prompt>
Получите cookie из запроса.
</Prompt>
<StarterCode>
```go
package main

import "fmt"

func main() {
    fmt.Println("Чтение: c, _ := r.Cookie(\"name\")")
}
```
</StarterCode>
<ExpectedOutput>
Чтение: c, _ := r.Cookie("name")
</ExpectedOutput>
</Task>

<Task id="3" points="15">
<Title>Задание 3: Атрибуты cookie</Title>
<Prompt>
Настройте безопасность cookie.
</Prompt>
<StarterCode>
```go
package main

import "fmt"

func main() {
    fmt.Println("Атрибуты: HttpOnly, Secure, SameSite")
}
```
</StarterCode>
<ExpectedOutput>
Атрибуты: HttpOnly, Secure, SameSite
</ExpectedOutput>
</Task>

<Task id="4" points="10">
<Title>Задание 4: Срок действия cookie</Title>
<Prompt>
Установите время жизни.
</Prompt>
<StarterCode>
```go
package main

import "fmt"

func main() {
    fmt.Println("Срок: Expires или MaxAge")
}
```
</StarterCode>
<ExpectedOutput>
Срок: Expires или MaxAge
</ExpectedOutput>
</Task>

<Task id="5" points="10">
<Title>Задание 5: Удаление cookie</Title>
<Prompt>
Удалите cookie.
</Prompt>
<StarterCode>
```go
package main

import "fmt"

func main() {
    fmt.Println("Удаление: MaxAge = -1")
}
```
</StarterCode>
<ExpectedOutput>
Удаление: MaxAge = -1
</ExpectedOutput>
</Task>
