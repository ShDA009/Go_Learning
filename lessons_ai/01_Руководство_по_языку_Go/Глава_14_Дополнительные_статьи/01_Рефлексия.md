# –†–µ—Ñ–ª–µ–∫—Å–∏—è (reflect)

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **–†–µ—Ñ–ª–µ–∫—Å–∏—è** ‚Äî –∏—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Ç–∏–ø–æ–≤ –∏ –∑–Ω–∞—á–µ–Ω–∏–π –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
2. **reflect.TypeOf** ‚Äî –ø–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
3. **reflect.ValueOf** ‚Äî –ø–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
4. **Kind** ‚Äî –±–∞–∑–æ–≤—ã–π —Ç–∏–ø (int, string, struct, slice, etc.)
5. **–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ** ‚Äî —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è, ORM, dependency injection

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### –û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

```go
// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–ø–∞
reflect.TypeOf(v interface{}) reflect.Type

// –ü–æ–ª—É—á–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
reflect.ValueOf(v interface{}) reflect.Value
```

### –ú–µ—Ç–æ–¥—ã Type

```go
type.Name()           // –∏–º—è —Ç–∏–ø–∞
type.Kind()           // –±–∞–∑–æ–≤—ã–π —Ç–∏–ø
type.NumField()       // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
type.Field(i)         // –ø–æ–ª–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É
type.NumMethod()      // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –º–µ—Ç–æ–¥–æ–≤
type.Method(i)        // –º–µ—Ç–æ–¥ –ø–æ –∏–Ω–¥–µ–∫—Å—É
```

### –ú–µ—Ç–æ–¥—ã Value

```go
value.Type()          // —Ç–∏–ø –∑–Ω–∞—á–µ–Ω–∏—è
value.Kind()          // –±–∞–∑–æ–≤—ã–π —Ç–∏–ø
value.Interface()     // –∏—Å—Ö–æ–¥–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
value.NumField()      // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–µ–π
value.Field(i)        // –ø–æ–ª–µ –ø–æ –∏–Ω–¥–µ–∫—Å—É
value.CanSet()        // –º–æ–∂–Ω–æ –ª–∏ –∏–∑–º–µ–Ω–∏—Ç—å
value.Set(v)          // —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    var x int = 42
    var s string = "hello"
    var f float64 = 3.14
    
    fmt.Println("x type:", reflect.TypeOf(x))  // int
    fmt.Println("s type:", reflect.TypeOf(s))  // string
    fmt.Println("f type:", reflect.TypeOf(f))  // float64
    
    // –°—Ä–µ–∑—ã –∏ map
    slice := []int{1, 2, 3}
    m := map[string]int{"a": 1}
    
    fmt.Println("slice type:", reflect.TypeOf(slice))  // []int
    fmt.Println("map type:", reflect.TypeOf(m))        // map[string]int
}
```

### –ò—Å—Å–ª–µ–¥–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```go
package main

import (
    "fmt"
    "reflect"
)

type Person struct {
    Name string
    Age  int
    City string
}

func main() {
    p := Person{Name: "Tom", Age: 30, City: "Moscow"}
    
    t := reflect.TypeOf(p)
    v := reflect.ValueOf(p)
    
    fmt.Println("Type:", t.Name())          // Person
    fmt.Println("Kind:", t.Kind())          // struct
    fmt.Println("Fields:", t.NumField())    // 3
    
    // –ü–µ—Ä–µ–±–æ—Ä –ø–æ–ª–µ–π
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        value := v.Field(i)
        
        fmt.Printf("Field %d: %s (%s) = %v\n", 
            i, field.Name, field.Type, value.Interface())
    }
}
// Output:
// Type: Person
// Kind: struct
// Fields: 3
// Field 0: Name (string) = Tom
// Field 1: Age (int) = 30
// Field 2: City (string) = Moscow
```

### Kind ‚Äî –±–∞–∑–æ–≤—ã–π —Ç–∏–ø

```go
package main

import (
    "fmt"
    "reflect"
)

type MyInt int
type MyString string

func main() {
    var x MyInt = 42
    var s MyString = "hello"
    
    xType := reflect.TypeOf(x)
    sType := reflect.TypeOf(s)
    
    // Name ‚Äî –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–æ–≥–æ —Ç–∏–ø–∞
    fmt.Println("x Name:", xType.Name())   // MyInt
    fmt.Println("s Name:", sType.Name())   // MyString
    
    // Kind ‚Äî –±–∞–∑–æ–≤—ã–π —Ç–∏–ø
    fmt.Println("x Kind:", xType.Kind())   // int
    fmt.Println("s Kind:", sType.Kind())   // string
}
```

### –ò–∑–º–µ–Ω–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π —á–µ—Ä–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é

```go
package main

import (
    "fmt"
    "reflect"
)

func main() {
    x := 42
    
    // –ù—É–∂–µ–Ω —É–∫–∞–∑–∞—Ç–µ–ª—å –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è!
    v := reflect.ValueOf(&x).Elem()
    
    if v.CanSet() {
        v.SetInt(100)
    }
    
    fmt.Println("x:", x)  // 100
}
```

### –ò–∑–º–µ–Ω–µ–Ω–∏–µ –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```go
package main

import (
    "fmt"
    "reflect"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    p := Person{Name: "Tom", Age: 30}
    
    // –ü–µ—Ä–µ–¥–∞—ë–º —É–∫–∞–∑–∞—Ç–µ–ª—å
    v := reflect.ValueOf(&p).Elem()
    
    // –ò–∑–º–µ–Ω—è–µ–º –ø–æ–ª—è
    nameField := v.FieldByName("Name")
    if nameField.CanSet() {
        nameField.SetString("Alice")
    }
    
    ageField := v.FieldByName("Age")
    if ageField.CanSet() {
        ageField.SetInt(25)
    }
    
    fmt.Printf("%+v\n", p)  // {Name:Alice Age:25}
}
```

### –†–∞–±–æ—Ç–∞ —Å —Ç–µ–≥–∞–º–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```go
package main

import (
    "fmt"
    "reflect"
)

type User struct {
    ID    int    `json:"id" db:"user_id"`
    Name  string `json:"name" db:"user_name"`
    Email string `json:"email" db:"email"`
}

func main() {
    t := reflect.TypeOf(User{})
    
    for i := 0; i < t.NumField(); i++ {
        field := t.Field(i)
        
        jsonTag := field.Tag.Get("json")
        dbTag := field.Tag.Get("db")
        
        fmt.Printf("%s: json=%s, db=%s\n", field.Name, jsonTag, dbTag)
    }
}
// Output:
// ID: json=id, db=user_id
// Name: json=name, db=user_name
// Email: json=email, db=email
```

### –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–æ–≤ —á–µ—Ä–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é

```go
package main

import (
    "fmt"
    "reflect"
)

type Calculator struct{}

func (c Calculator) Add(a, b int) int {
    return a + b
}

func (c Calculator) Multiply(a, b int) int {
    return a * b
}

func main() {
    calc := Calculator{}
    v := reflect.ValueOf(calc)
    
    // –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ Add
    addMethod := v.MethodByName("Add")
    args := []reflect.Value{
        reflect.ValueOf(5),
        reflect.ValueOf(3),
    }
    
    result := addMethod.Call(args)
    fmt.Println("5 + 3 =", result[0].Int())  // 8
    
    // –í—ã–∑–æ–≤ –º–µ—Ç–æ–¥–∞ Multiply
    mulMethod := v.MethodByName("Multiply")
    result = mulMethod.Call(args)
    fmt.Println("5 * 3 =", result[0].Int())  // 15
}
```

### –°–æ–∑–¥–∞–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤ —á–µ—Ä–µ–∑ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é

```go
package main

import (
    "fmt"
    "reflect"
)

type Person struct {
    Name string
    Age  int
}

func main() {
    // –ü–æ–ª—É—á–∞–µ–º —Ç–∏–ø
    t := reflect.TypeOf(Person{})
    
    // –°–æ–∑–¥–∞—ë–º –Ω–æ–≤—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä
    v := reflect.New(t).Elem()
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏—è
    v.FieldByName("Name").SetString("Bob")
    v.FieldByName("Age").SetInt(35)
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –æ–±—Ä–∞—Ç–Ω–æ
    person := v.Interface().(Person)
    
    fmt.Printf("%+v\n", person)  // {Name:Bob Age:35}
}
```

### –£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—á–∞—Ç–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```go
package main

import (
    "fmt"
    "reflect"
)

func PrintStruct(v interface{}) {
    val := reflect.ValueOf(v)
    typ := reflect.TypeOf(v)
    
    if typ.Kind() != reflect.Struct {
        fmt.Println("Not a struct!")
        return
    }
    
    fmt.Printf("=== %s ===\n", typ.Name())
    
    for i := 0; i < typ.NumField(); i++ {
        field := typ.Field(i)
        value := val.Field(i)
        
        fmt.Printf("  %s: %v\n", field.Name, value.Interface())
    }
}

type Person struct {
    Name string
    Age  int
}

type Product struct {
    ID    int
    Title string
    Price float64
}

func main() {
    PrintStruct(Person{Name: "Alice", Age: 30})
    fmt.Println()
    PrintStruct(Product{ID: 1, Title: "Phone", Price: 999.99})
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ –≤ runtime

```go
package main

import (
    "fmt"
    "reflect"
)

func TypeName(v interface{}) string {
    t := reflect.TypeOf(v)
    if t == nil {
        return "nil"
    }
    return t.String()
}

func IsSlice(v interface{}) bool {
    return reflect.TypeOf(v).Kind() == reflect.Slice
}

func IsMap(v interface{}) bool {
    return reflect.TypeOf(v).Kind() == reflect.Map
}

func main() {
    fmt.Println(TypeName(42))           // int
    fmt.Println(TypeName("hello"))      // string
    fmt.Println(TypeName([]int{1,2}))   // []int
    
    fmt.Println(IsSlice([]int{1,2}))    // true
    fmt.Println(IsSlice("hello"))       // false
    
    fmt.Println(IsMap(map[string]int{})) // true
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ò–∑–º–µ–Ω–µ–Ω–∏–µ –±–µ–∑ —É–∫–∞–∑–∞—Ç–µ–ª—è

```go
// ‚ùå –ù–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
x := 42
v := reflect.ValueOf(x)
v.SetInt(100)  // panic: reflect.Value.SetInt using unaddressable value

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —É–∫–∞–∑–∞—Ç–µ–ª—å
v := reflect.ValueOf(&x).Elem()
v.SetInt(100)  // OK
```

### 2. –ù–µ—ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º—ã–µ –ø–æ–ª—è

```go
type Person struct {
    name string  // –º–∞–ª–µ–Ω—å–∫–∞—è –±—É–∫–≤–∞ - –Ω–µ—ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º–æ–µ
    Age  int
}

// ‚ùå –ù–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å –Ω–µ—ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º–æ–µ –ø–æ–ª–µ
v.FieldByName("name").SetString("New")  // panic

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º—ã–µ –ø–æ–ª—è (—Å –±–æ–ª—å—à–æ–π –±—É–∫–≤—ã)
```

### 3. –ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å

```go
// ‚ùå –†–µ—Ñ–ª–µ–∫—Å–∏—è –º–µ–¥–ª–µ–Ω–Ω–∞—è –≤ –∫—Ä–∏—Ç–∏—á–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö
for i := 0; i < 1000000; i++ {
    reflect.TypeOf(x)  // –º–µ–¥–ª–µ–Ω–Ω–æ
}

// ‚úÖ –ö—ç—à–∏—Ä—É–π—Ç–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
t := reflect.TypeOf(x)
for i := 0; i < 1000000; i++ {
    // –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ t
}
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞—á–∞ 1: Struct to map
–ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–π—Ç–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤ map[string]interface{}.

### –ó–∞–¥–∞—á–∞ 2: Deep copy
–°–æ–∑–¥–∞–π—Ç–µ –≥–ª—É–±–æ–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.

### –ó–∞–¥–∞—á–∞ 3: JSON encoder
–ü—Ä–æ—Å—Ç–æ–π JSON encoder —Å —Ä–µ—Ñ–ª–µ–∫—Å–∏–µ–π.

### –ó–∞–¥–∞—á–∞ 4: Validator
–í–∞–ª–∏–¥–∞—Ü–∏—è –ø–æ–ª–µ–π –ø–æ —Ç–µ–≥–∞–º.

### –ó–∞–¥–∞—á–∞ 5: Dependency injection
–ü—Ä–æ—Å—Ç–æ–π DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä.

### –ó–∞–¥–∞—á–∞ 6: ORM mapper
–ú–∞–ø–ø–∏–Ω–≥ –ë–î –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.

### –ó–∞–¥–∞—á–∞ 7: Config loader
–ó–∞–≥—Ä—É–∑–∫–∞ –∫–æ–Ω—Ñ–∏–≥–∞ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏–∑ env.

### –ó–∞–¥–∞—á–∞ 8: Test generator
–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä.
