# –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å –ø–æ–º–æ—â—å—é –∫–∞–Ω–∞–ª–æ–≤

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **–ö–∞–Ω–∞–ª—ã –¥–ª—è —Å–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏–∏** ‚Äî –ø–µ—Ä–µ–¥–∞—á–∞ —Å–∏–≥–Ω–∞–ª–∞ –æ —Å–æ–±—ã—Ç–∏–∏, –∞ –Ω–µ –¥–∞–Ω–Ω—ã—Ö
2. **Done channel** ‚Äî –ø—É—Å—Ç–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ `chan struct{}` –¥–ª—è —Å–∏–≥–Ω–∞–ª–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
3. **–ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞** ‚Äî –æ–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ –∫–∞–Ω–∞–ª–∞ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –≥–æ—Ä—É—Ç–∏–Ω—ã
4. **–ó–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–∫ broadcast** ‚Äî –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞ —É–≤–µ–¥–æ–º–ª—è–µ—Ç –≤—Å–µ—Ö –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–π
5. **–ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è** ‚Äî –∫–∞–Ω–∞–ª—ã –ø–æ–∑–≤–æ–ª—è—é—Ç —É–ø–æ—Ä—è–¥–æ—á–∏—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –≥–æ—Ä—É—Ç–∏–Ω

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### –°–∏–≥–Ω–∞–ª—å–Ω—ã–µ –∫–∞–Ω–∞–ª—ã

```go
// –ö–∞–Ω–∞–ª –¥–ª—è —Å–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏–∏ (–±–µ–∑ –¥–∞–Ω–Ω—ã—Ö)
done := make(chan struct{})

// –°–∏–≥–Ω–∞–ª–∏–∑–∞—Ü–∏—è —á–µ—Ä–µ–∑ –∑–∞–∫—Ä—ã—Ç–∏–µ
close(done)

// –û–∂–∏–¥–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞
<-done
```

### –ö–∞–Ω–∞–ª bool –¥–ª—è —Å—Ç–∞—Ç—É—Å–∞

```go
ready := make(chan bool)
ready <- true   // –≥–æ—Ç–æ–≤–æ
ready <- false  // –Ω–µ –≥–æ—Ç–æ–≤–æ
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –≥–æ—Ä—É—Ç–∏–Ω—ã

```go
package main

import (
    "fmt"
    "time"
)

func worker(done chan struct{}) {
    fmt.Println("Working...")
    time.Sleep(2 * time.Second)
    fmt.Println("Done!")
    
    close(done)  // —Å–∏–≥–Ω–∞–ª –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
}

func main() {
    done := make(chan struct{})
    
    go worker(done)
    
    fmt.Println("Waiting for worker...")
    <-done  // –±–ª–æ–∫–∏—Ä—É–µ–º—Å—è –¥–æ –∑–∞–∫—Ä—ã—Ç–∏—è
    
    fmt.Println("Worker finished, exiting.")
}
```

### –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –≥–æ—Ä—É—Ç–∏–Ω

```go
package main

import (
    "fmt"
    "time"
)

func worker(id int, done chan bool) {
    fmt.Printf("Worker %d: starting\n", id)
    time.Sleep(time.Duration(id*100) * time.Millisecond)
    fmt.Printf("Worker %d: done\n", id)
    
    done <- true  // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–∏–≥–Ω–∞–ª
}

func main() {
    done := make(chan bool)
    workerCount := 5
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –≥–æ—Ä—É—Ç–∏–Ω—ã
    for i := 1; i <= workerCount; i++ {
        go worker(i, done)
    }
    
    // –ñ–¥—ë–º –≤—Å–µ –≥–æ—Ä—É—Ç–∏–Ω—ã
    for i := 1; i <= workerCount; i++ {
        <-done
    }
    
    fmt.Println("All workers completed!")
}
```

### –ü–µ—Ä–µ–¥–∞—á–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª

```go
package main

import "fmt"

type Result struct {
    Value int
    Error error
}

func compute(n int, resultCh chan<- Result) {
    if n < 0 {
        resultCh <- Result{Error: fmt.Errorf("negative number: %d", n)}
        return
    }
    
    result := n * n
    resultCh <- Result{Value: result}
}

func main() {
    resultCh := make(chan Result)
    
    go compute(5, resultCh)
    
    result := <-resultCh
    if result.Error != nil {
        fmt.Println("Error:", result.Error)
    } else {
        fmt.Println("Result:", result.Value)
    }
}
```

### –°–±–æ—Ä —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –≤ map

```go
package main

import "fmt"

func square(n int, done chan struct{}, results map[int]int) {
    results[n] = n * n
    close(done)
}

func main() {
    results := make(map[int]int)
    done := make(chan struct{})
    
    go square(7, done, results)
    
    <-done  // –∂–¥—ë–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
    
    for k, v := range results {
        fmt.Printf("%d¬≤ = %d\n", k, v)
    }
}
```

### –ü–∞—Ç—Ç–µ—Ä–Ω: Start/Stop

```go
package main

import (
    "fmt"
    "time"
)

type Server struct {
    stop chan struct{}
}

func NewServer() *Server {
    return &Server{stop: make(chan struct{})}
}

func (s *Server) Start() {
    go func() {
        ticker := time.NewTicker(500 * time.Millisecond)
        defer ticker.Stop()
        
        for {
            select {
            case <-s.stop:
                fmt.Println("Server stopped")
                return
            case t := <-ticker.C:
                fmt.Println("Tick at", t.Format("15:04:05"))
            }
        }
    }()
}

func (s *Server) Stop() {
    close(s.stop)
}

func main() {
    server := NewServer()
    
    fmt.Println("Starting server...")
    server.Start()
    
    time.Sleep(2 * time.Second)
    
    fmt.Println("Stopping server...")
    server.Stop()
    
    time.Sleep(500 * time.Millisecond)
}
```

### –ö–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è: Barrier

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func worker(id int, ready chan struct{}, start chan struct{}, wg *sync.WaitGroup) {
    defer wg.Done()
    
    fmt.Printf("Worker %d: preparing...\n", id)
    time.Sleep(time.Duration(id*100) * time.Millisecond)
    
    ready <- struct{}{}  // —Å–∏–≥–Ω–∞–ª "–≥–æ—Ç–æ–≤"
    
    <-start  // –∂–¥—ë–º —Å–∏–≥–Ω–∞–ª–∞ —Å—Ç–∞—Ä—Ç–∞
    
    fmt.Printf("Worker %d: working!\n", id)
}

func main() {
    var wg sync.WaitGroup
    
    ready := make(chan struct{})
    start := make(chan struct{})
    workerCount := 3
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –≤–æ—Ä–∫–µ—Ä–æ–≤
    for i := 1; i <= workerCount; i++ {
        wg.Add(1)
        go worker(i, ready, start, &wg)
    }
    
    // –ñ–¥—ë–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –≤—Å–µ—Ö
    for i := 0; i < workerCount; i++ {
        <-ready
    }
    
    fmt.Println("\nAll ready! Starting...")
    close(start)  // broadcast: –≤—Å–µ –Ω–∞—á–∏–Ω–∞—é—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
    
    wg.Wait()
}
```

### Request/Response —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã

```go
package main

import (
    "fmt"
    "time"
)

type Request struct {
    Data     int
    Response chan int
}

func server(requests <-chan Request) {
    for req := range requests {
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å
        result := req.Data * 2
        time.Sleep(100 * time.Millisecond)
        
        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç
        req.Response <- result
    }
}

func main() {
    requests := make(chan Request)
    
    go server(requests)
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–ø—Ä–æ—Å—ã
    for i := 1; i <= 3; i++ {
        response := make(chan int)
        
        requests <- Request{Data: i * 10, Response: response}
        
        result := <-response
        fmt.Printf("Request %d: got %d\n", i, result)
    }
    
    close(requests)
}
```

### –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: Task Queue —Å acknowledgment

```go
package main

import (
    "fmt"
    "time"
)

type Task struct {
    ID   int
    Done chan struct{}
}

func processor(tasks <-chan Task) {
    for task := range tasks {
        fmt.Printf("Processing task %d...\n", task.ID)
        time.Sleep(500 * time.Millisecond)
        fmt.Printf("Task %d complete!\n", task.ID)
        
        close(task.Done)  // –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
    }
}

func main() {
    tasks := make(chan Task)
    
    go processor(tasks)
    
    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∑–∞–¥–∞—á–∏ –∏ –∂–¥—ë–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
    for i := 1; i <= 3; i++ {
        task := Task{
            ID:   i,
            Done: make(chan struct{}),
        }
        
        tasks <- task
        
        <-task.Done  // –∂–¥—ë–º –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        fmt.Printf("Task %d acknowledged\n", i)
    }
    
    close(tasks)
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–∏–≥–Ω–∞–ª–æ–≤

```go
done := make(chan bool)

// –ó–∞–ø—É—Å–∫–∞–µ–º 3 –≥–æ—Ä—É—Ç–∏–Ω—ã
for i := 0; i < 3; i++ {
    go func() {
        done <- true
    }()
}

// ‚ùå –ñ–¥—ë–º —Ç–æ–ª—å–∫–æ 2 ‚Äî —Ç—Ä–µ—Ç—å—è –∑–∞–±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è
<-done
<-done

// ‚úÖ –ñ–¥—ë–º –≤—Å–µ 3
for i := 0; i < 3; i++ {
    <-done
}
```

### 2. –ì–æ–Ω–∫–∞ –ø—Ä–∏ –∑–∞–ø–∏—Å–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤

```go
results := make(map[int]int)

for i := 0; i < 3; i++ {
    go func(n int) {
        results[n] = n * n  // ‚ùå –ì–æ–Ω–∫–∞ –¥–∞–Ω–Ω—ã—Ö!
    }(i)
}

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–∞–Ω–∞–ª –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
resultCh := make(chan struct{ key, value int }, 3)

for i := 0; i < 3; i++ {
    go func(n int) {
        resultCh <- struct{ key, value int }{n, n * n}
    }(i)
}
```

### 3. –£—Ç–µ—á–∫–∞ –≥–æ—Ä—É—Ç–∏–Ω—ã –ø—Ä–∏ –Ω–µ–ø–æ–ª—É—á–µ–Ω–Ω–æ–º —Å–∏–≥–Ω–∞–ª–µ

```go
func process() {
    done := make(chan struct{})
    
    go func() {
        // —Ä–∞–±–æ—Ç–∞...
        close(done)  // ‚ùå –ï—Å–ª–∏ main –≤–µ—Ä–Ω—ë—Ç—Å—è —Ä–∞–Ω—å—à–µ, –≥–æ—Ä—É—Ç–∏–Ω–∞ –∑–∞—Å—Ç—Ä—è–Ω–µ—Ç
    }()
    
    // –ó–∞–±—ã–ª–∏ <-done
}

// ‚úÖ –í—Å–µ–≥–¥–∞ –¥–æ–∂–∏–¥–∞–π—Ç–µ—Å—å —Å–∏–≥–Ω–∞–ª–∞
func processCorrect() {
    done := make(chan struct{})
    
    go func() {
        // —Ä–∞–±–æ—Ç–∞...
        close(done)
    }()
    
    <-done  // –ñ–¥—ë–º!
}
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞—á–∞ 1: Countdown
–°–æ–∑–¥–∞–π—Ç–µ –≥–æ—Ä—É—Ç–∏–Ω—É-—Ç–∞–π–º–µ—Ä –æ–±—Ä–∞—Ç–Ω–æ–≥–æ –æ—Ç—Å—á—ë—Ç–∞ —Å —Å–∏–≥–Ω–∞–ª–æ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.

### –ó–∞–¥–∞—á–∞ 2: Pipeline sync
–°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–π—Ç–µ —Ç—Ä–∏ —Å—Ç–∞–¥–∏–∏ –∫–æ–Ω–≤–µ–π–µ—Ä–∞ —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã.

### –ó–∞–¥–∞—á–∞ 3: Barrier
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –±–∞—Ä—å–µ—Ä –¥–ª—è N –≥–æ—Ä—É—Ç–∏–Ω (–≤—Å–µ –∂–¥—É—Ç, –ø–æ—Ç–æ–º –≤—Å–µ –ø—Ä–æ–¥–æ–ª–∂–∞—é—Ç).

### –ó–∞–¥–∞—á–∞ 4: Heartbeat
–°–æ–∑–¥–∞–π—Ç–µ –≥–æ—Ä—É—Ç–∏–Ω—É, –æ—Ç–ø—Ä–∞–≤–ª—è—é—â—É—é –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∏–µ "heartbeat" —Å–∏–≥–Ω–∞–ª—ã.

### –ó–∞–¥–∞—á–∞ 5: Task with timeout
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ —Å —Ç–∞–π–º–∞—É—Ç–æ–º —á–µ—Ä–µ–∑ select.

### –ó–∞–¥–∞—á–∞ 6: Request limiter
–û–≥—Ä–∞–Ω–∏—á—å—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –∑–∞–ø—Ä–æ—Å–æ–≤ —Å –ø–æ–º–æ—â—å—é –∫–∞–Ω–∞–ª–∞.

### –ó–∞–¥–∞—á–∞ 7: Graceful shutdown
–†–µ–∞–ª–∏–∑—É–π—Ç–µ graceful shutdown –¥–ª—è –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –≥–æ—Ä—É—Ç–∏–Ω.

### –ó–∞–¥–∞—á–∞ 8: Circuit breaker
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø—Ä–æ—Å—Ç–æ–π circuit breaker —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã —Å–æ—Å—Ç–æ—è–Ω–∏—è.
