# –ü–µ—Ä–µ–¥–∞—á–∞ –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö (Streaming)

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **–ü–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö** ‚Äî –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–π, –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã—Ö —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª
2. **–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä** ‚Äî —Ñ—É–Ω–∫—Ü–∏—è, —Å–æ–∑–¥–∞—é—â–∞—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è –∫–∞–Ω–∞–ª —Å –¥–∞–Ω–Ω—ã–º–∏
3. **for-range** ‚Äî –∏–¥–∏–æ–º–∞—Ç–∏—á–Ω—ã–π —Å–ø–æ—Å–æ–± —á—Ç–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ –¥–æ –∑–∞–∫—Ä—ã—Ç–∏—è
4. **defer close()** ‚Äî –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–µ–º
5. **Pipeline** ‚Äî —Ü–µ–ø–æ—á–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã
6. **–û—Ç–º–µ–Ω–∞** ‚Äî –º–µ—Ö–∞–Ω–∏–∑–º –¥–æ—Å—Ä–æ—á–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–æ—Ç–æ–∫–∞

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–æ—Ç–æ–∫–∞

```go
func generator() <-chan T {
    ch := make(chan T)
    go func() {
        defer close(ch)
        // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ ch
    }()
    return ch
}
```

### –ß—Ç–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–∞

```go
// –ß–µ—Ä–µ–∑ for-range (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ close)
for value := range ch {
    // –æ–±—Ä–∞–±–æ—Ç–∫–∞
}

// –í—Ä—É—á–Ω—É—é —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π
for {
    value, ok := <-ch
    if !ok {
        break
    }
    // –æ–±—Ä–∞–±–æ—Ç–∫–∞
}
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —á–∏—Å–µ–ª

```go
package main

import "fmt"

func counter(max int) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        for i := 1; i <= max; i++ {
            ch <- i
        }
    }()
    
    return ch
}

func main() {
    for num := range counter(5) {
        fmt.Println(num)
    }
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª–æ–≤

```go
package main

import "fmt"

func factorials(n int) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        
        result := 1
        for i := 1; i <= n; i++ {
            result *= i
            ch <- result
        }
    }()
    
    return ch
}

func main() {
    fmt.Println("Factorials:")
    for f := range factorials(7) {
        fmt.Println(f)
    }
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –§–∏–±–æ–Ω–∞—á—á–∏

```go
package main

import "fmt"

func fibonacci(max int) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        
        a, b := 0, 1
        for a <= max {
            ch <- a
            a, b = b, a+b
        }
    }()
    
    return ch
}

func main() {
    fmt.Println("Fibonacci <= 100:")
    for f := range fibonacci(100) {
        fmt.Println(f)
    }
}
```

### Pipeline: –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä ‚Üí —Ñ–∏–ª—å—Ç—Ä ‚Üí –æ–±—Ä–∞–±–æ—Ç—á–∏–∫

```go
package main

import "fmt"

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–∏—Å–µ–ª
func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —á—ë—Ç–Ω—ã—Ö
func filterEven(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out <- n
            }
        }
    }()
    return out
}

// –í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

func main() {
    // Pipeline: gen -> filterEven -> square
    nums := gen(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    evens := filterEven(nums)
    squared := square(evens)
    
    for n := range squared {
        fmt.Println(n)  // 4, 16, 36, 64, 100
    }
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å –æ—Ç–º–µ–Ω–æ–π

```go
package main

import (
    "fmt"
    "time"
)

func infiniteCounter(done <-chan struct{}) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        
        i := 1
        for {
            select {
            case <-done:
                fmt.Println("Generator: cancelled")
                return
            case ch <- i:
                i++
            }
        }
    }()
    
    return ch
}

func main() {
    done := make(chan struct{})
    
    nums := infiniteCounter(done)
    
    // –ß–∏—Ç–∞–µ–º 5 —á–∏—Å–µ–ª
    for i := 0; i < 5; i++ {
        fmt.Println(<-nums)
    }
    
    // –û—Ç–º–µ–Ω—è–µ–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
    close(done)
    
    time.Sleep(100 * time.Millisecond)
    fmt.Println("Done!")
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏–∑ —Ñ–∞–π–ª–∞ (–∏–º–∏—Ç–∞—Ü–∏—è)

```go
package main

import (
    "fmt"
    "time"
)

type LogEntry struct {
    Time    string
    Level   string
    Message string
}

func readLogs() <-chan LogEntry {
    ch := make(chan LogEntry)
    
    go func() {
        defer close(ch)
        
        // –ò–º–∏—Ç–∞—Ü–∏—è —á—Ç–µ–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–∞
        logs := []LogEntry{
            {"10:00:01", "INFO", "Server started"},
            {"10:00:02", "DEBUG", "Loading config"},
            {"10:00:05", "WARNING", "High memory usage"},
            {"10:00:10", "ERROR", "Connection failed"},
        }
        
        for _, log := range logs {
            time.Sleep(100 * time.Millisecond)
            ch <- log
        }
    }()
    
    return ch
}

func main() {
    fmt.Println("Reading logs...")
    
    for log := range readLogs() {
        fmt.Printf("[%s] %s: %s\n", log.Time, log.Level, log.Message)
    }
    
    fmt.Println("All logs read!")
}
```

### Fan-Out: –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –æ–¥–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func producer(n int) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 1; i <= n; i++ {
            ch <- i
        }
    }()
    return ch
}

func worker(id int, jobs <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        time.Sleep(50 * time.Millisecond)
        fmt.Printf("Worker %d processed job %d\n", id, job)
    }
}

func main() {
    jobs := producer(10)
    
    var wg sync.WaitGroup
    
    // Fan-Out: 3 –≤–æ—Ä–∫–µ—Ä–∞ —á–∏—Ç–∞—é—Ç –∏–∑ –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞
    for w := 1; w <= 3; w++ {
        wg.Add(1)
        go worker(w, jobs, &wg)
    }
    
    wg.Wait()
}
```

### –ë—É—Ñ–µ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ç–æ–∫

```go
package main

import (
    "fmt"
    "time"
)

func bufferedProducer(n, bufSize int) <-chan int {
    ch := make(chan int, bufSize)  // –±—É—Ñ–µ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π!
    
    go func() {
        defer close(ch)
        
        for i := 1; i <= n; i++ {
            fmt.Printf("Producing: %d (buffer: %d/%d)\n", 
                i, len(ch), cap(ch))
            ch <- i
            time.Sleep(50 * time.Millisecond)
        }
    }()
    
    return ch
}

func main() {
    ch := bufferedProducer(10, 3)
    
    // –ú–µ–¥–ª–µ–Ω–Ω—ã–π –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å
    for n := range ch {
        time.Sleep(200 * time.Millisecond)
        fmt.Printf("  Consumed: %d\n", n)
    }
}
```

### –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: Word Count Pipeline

```go
package main

import (
    "fmt"
    "strings"
)

// –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å—Ç—Ä–æ–∫
func lines(text string) <-chan string {
    ch := make(chan string)
    go func() {
        defer close(ch)
        for _, line := range strings.Split(text, "\n") {
            if line != "" {
                ch <- line
            }
        }
    }()
    return ch
}

// –†–∞–∑–±–∏–≤–∫–∞ –Ω–∞ —Å–ª–æ–≤–∞
func words(in <-chan string) <-chan string {
    ch := make(chan string)
    go func() {
        defer close(ch)
        for line := range in {
            for _, word := range strings.Fields(line) {
                ch <- strings.ToLower(word)
            }
        }
    }()
    return ch
}

// –ü–æ–¥—Å—á—ë—Ç
func count(in <-chan string) <-chan map[string]int {
    ch := make(chan map[string]int)
    go func() {
        defer close(ch)
        counts := make(map[string]int)
        for word := range in {
            counts[word]++
        }
        ch <- counts
    }()
    return ch
}

func main() {
    text := `Hello World
Hello Go
Go is awesome
World of Go`

    // Pipeline: lines -> words -> count
    result := count(words(lines(text)))
    
    wordCounts := <-result
    
    for word, cnt := range wordCounts {
        fmt.Printf("%s: %d\n", word, cnt)
    }
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ó–∞–±—ã–ª–∏ –∑–∞–∫—Ä—ã—Ç—å –∫–∞–Ω–∞–ª

```go
func gen() <-chan int {
    ch := make(chan int)
    go func() {
        ch <- 1
        ch <- 2
        // ‚ùå –ó–∞–±—ã–ª–∏ close(ch)
    }()
    return ch
}

// for-range –∑–∞–≤–∏—Å–Ω–µ—Ç –Ω–∞–≤—Å–µ–≥–¥–∞
for v := range gen() {
    fmt.Println(v)
}
```

### 2. –ó–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–º

```go
// ‚ùå –ü–æ–ª—É—á–∞—Ç–µ–ª—å –∑–∞–∫—Ä—ã–≤–∞–µ—Ç ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –º–æ–∂–µ—Ç –ø–∞–Ω–∏–∫–æ–≤–∞—Ç—å
func consumer(ch chan int) {
    for v := range ch {
        fmt.Println(v)
    }
    close(ch)  // ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û!
}
```

### 3. –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω—ã

```go
// ‚ùå –ì–æ—Ä—É—Ç–∏–Ω–∞ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –æ—Ç–º–µ–Ω—É
func gen(done <-chan struct{}) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; ; i++ {
            ch <- i  // –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –µ—Å–ª–∏ –Ω–∏–∫—Ç–æ –Ω–µ —á–∏—Ç–∞–µ—Ç!
        }
    }()
    return ch
}

// ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º done
func genCorrect(done <-chan struct{}) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; ; i++ {
            select {
            case <-done:
                return
            case ch <- i:
            }
        }
    }()
    return ch
}
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞—á–∞ 1: Prime Generator
–°–æ–∑–¥–∞–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø—Ä–æ—Å—Ç—ã—Ö —á–∏—Å–µ–ª –¥–æ N.

### –ó–∞–¥–∞—á–∞ 2: File Lines
–°–æ–∑–¥–∞–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä, —á–∏—Ç–∞—é—â–∏–π —Å—Ç—Ä–æ–∫–∏ –∏–∑ —Ñ–∞–π–ª–∞ (–∏–º–∏—Ç–∞—Ü–∏—è).

### –ó–∞–¥–∞—á–∞ 3: Batch
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –≥—Ä—É–ø–ø–∏—Ä—É—é—â—É—é –ø–æ—Ç–æ–∫ –ø–æ N —ç–ª–µ–º–µ–Ω—Ç–æ–≤.

### –ó–∞–¥–∞—á–∞ 4: Throttle
–°–æ–∑–¥–∞–π—Ç–µ throttle, –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞—é—â–∏–π —Å–∫–æ—Ä–æ—Å—Ç—å –ø–æ—Ç–æ–∫–∞ –¥–æ N —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É.

### –ó–∞–¥–∞—á–∞ 5: Merge sorted
–û–±—ä–µ–¥–∏–Ω–∏—Ç–µ –¥–≤–∞ –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ—Ç–æ–∫–∞ –≤ –æ–¥–∏–Ω –æ—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π.

### –ó–∞–¥–∞—á–∞ 6: Distinct
–°–æ–∑–¥–∞–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä, –ø—Ä–æ–ø—É—Å–∫–∞—é—â–∏–π —Ç–æ–ª—å–∫–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã.

### –ó–∞–¥–∞—á–∞ 7: Map/Reduce
–†–µ–∞–ª–∏–∑—É–π—Ç–µ MapReduce —á–µ—Ä–µ–∑ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä—ã.

### –ó–∞–¥–∞—á–∞ 8: CSV Parser
–°–æ–∑–¥–∞–π—Ç–µ –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä, –ø–∞—Ä—Å—è—â–∏–π CSV –∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.
