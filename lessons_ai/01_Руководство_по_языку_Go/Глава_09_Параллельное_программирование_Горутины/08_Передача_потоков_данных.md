# –ü–µ—Ä–µ–¥–∞—á–∞ –ø–æ—Ç–æ–∫–æ–≤ –¥–∞–Ω–Ω—ã—Ö (Streaming)

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **–ü–æ—Ç–æ–∫ –¥–∞–Ω–Ω—ã—Ö** ‚Äî –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∑–Ω–∞—á–µ–Ω–∏–π, –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã—Ö —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª
2. **–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä** ‚Äî —Ñ—É–Ω–∫—Ü–∏—è, —Å–æ–∑–¥–∞—é—â–∞—è –∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è –∫–∞–Ω–∞–ª —Å –¥–∞–Ω–Ω—ã–º–∏
3. **for-range** ‚Äî –∏–¥–∏–æ–º–∞—Ç–∏—á–Ω—ã–π —Å–ø–æ—Å–æ–± —á—Ç–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞ –¥–æ –∑–∞–∫—Ä—ã—Ç–∏—è
4. **defer close()** ‚Äî –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª–µ–º
5. **Pipeline** ‚Äî —Ü–µ–ø–æ—á–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π —á–µ—Ä–µ–∑ –∫–∞–Ω–∞–ª—ã
6. **–û—Ç–º–µ–Ω–∞** ‚Äî –º–µ—Ö–∞–Ω–∏–∑–º –¥–æ—Å—Ä–æ—á–Ω–æ–π –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –ø–æ—Ç–æ–∫–∞

---

## üìñ –¢–µ–æ—Ä–∏—è

### –ß—Ç–æ —Ç–∞–∫–æ–µ –ø–æ—Ç–æ–∫–æ–≤–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞?

**Streaming** ‚Äî —ç—Ç–æ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ –º–µ—Ä–µ –∏—Ö –ø–æ—Å—Ç—É–ø–ª–µ–Ω–∏—è, –±–µ–∑ –∑–∞–≥—Ä—É–∑–∫–∏ –≤—Å–µ–≥–æ –≤ –ø–∞–º—è—Ç—å:

```go
// –ù–ï –ø–æ—Ç–æ–∫–æ–≤–∞—è ‚Äî –≥—Ä—É–∑–∏–º –≤—Å—ë –≤ –ø–∞–º—è—Ç—å
data := loadAllData()  // 10GB –≤ –ø–∞–º—è—Ç–∏!
process(data)

// –ü–æ—Ç–æ–∫–æ–≤–∞—è ‚Äî –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –ø–æ —á–∞—Å—Ç—è–º
for item := range dataStream() {
    process(item)  // –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç –∑–∞ —Ä–∞–∑
}
```

### –ü–∞—Ç—Ç–µ—Ä–Ω Generator (–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä)

–§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞—ë—Ç –∫–∞–Ω–∞–ª –∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç –µ–≥–æ –≤ –≥–æ—Ä—É—Ç–∏–Ω–µ:

```go
func numbers(n int) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)  // –≤–∞–∂–Ω–æ –∑–∞–∫—Ä—ã—Ç—å!
        for i := 0; i < n; i++ {
            ch <- i
        }
    }()
    return ch  // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º read-only –∫–∞–Ω–∞–ª
}

// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
for n := range numbers(1000) {
    fmt.Println(n)
}
```

### –ü–∞—Ç—Ç–µ—Ä–Ω Pipeline (–ö–æ–Ω–≤–µ–π–µ—Ä)

–¶–µ–ø–æ—á–∫–∞ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π –¥–∞–Ω–Ω—ã—Ö:

```go
// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è ‚Üí –£–¥–≤–æ–µ–Ω–∏–µ ‚Üí –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è ‚Üí –í—ã–≤–æ–¥

func double(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * 2
        }
    }()
    return out
}

func filter(in <-chan int, pred func(int) bool) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if pred(n) {
                out <- n
            }
        }
    }()
    return out
}

// –°–æ–±–∏—Ä–∞–µ–º –∫–æ–Ω–≤–µ–π–µ—Ä
nums := numbers(100)
doubled := double(nums)
even := filter(doubled, func(n int) bool { return n%4 == 0 })

for n := range even {
    fmt.Println(n)
}
```

### Fan-out: —Ä–∞—Å–ø–∞—Ä–∞–ª–ª–µ–ª–∏–≤–∞–Ω–∏–µ

–ù–µ—Å–∫–æ–ª—å–∫–æ –≥–æ—Ä—É—Ç–∏–Ω —á–∏—Ç–∞—é—Ç –∏–∑ –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞:

```go
jobs := make(chan Job)

// 3 –≤–æ—Ä–∫–µ—Ä–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
for i := 0; i < 3; i++ {
    go worker(jobs)
}
```

### Fan-in: –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ

–ù–µ—Å–∫–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª–æ–≤ –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è –≤ –æ–¥–∏–Ω:

```go
func merge(channels ...<-chan int) <-chan int {
    out := make(chan int)
    var wg sync.WaitGroup
    
    for _, ch := range channels {
        wg.Add(1)
        go func(c <-chan int) {
            defer wg.Done()
            for n := range c {
                out <- n
            }
        }(ch)
    }
    
    go func() {
        wg.Wait()
        close(out)
    }()
    
    return out
}
```

### –û—Ç–º–µ–Ω–∞ –ø–æ—Ç–æ–∫–∞

–ß–µ—Ä–µ–∑ done-–∫–∞–Ω–∞–ª:

```go
func generator(done <-chan struct{}) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; ; i++ {
            select {
            case <-done:
                return  // –ø—Ä–µ—Ä—ã–≤–∞–µ–º –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ
            case ch <- i:
            }
        }
    }()
    return ch
}
```

### –¢–∏–ø–∏—á–Ω—ã–µ –æ—à–∏–±–∫–∏

1. **–ó–∞–±—ã–ª–∏ close()** ‚Üí —É—Ç–µ—á–∫–∞ –≥–æ—Ä—É—Ç–∏–Ω
2. **–ó–∞–±—ã–ª–∏ defer** ‚Üí –ø–∞–Ω–∏–∫–∞ –ø—Ä–∏ –æ—à–∏–±–∫–µ
3. **–ù–µ—Ç –æ—Ç–º–µ–Ω—ã** ‚Üí –≥–æ—Ä—É—Ç–∏–Ω—ã-–∑–æ–º–±–∏

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –ø–æ—Ç–æ–∫–∞

```go
func generator() <-chan T {
    ch := make(chan T)
    go func() {
        defer close(ch)
        // –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ ch
    }()
    return ch
}
```

### –ß—Ç–µ–Ω–∏–µ –ø–æ—Ç–æ–∫–∞

```go
// –ß–µ—Ä–µ–∑ for-range (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –≤—ã—Ö–æ–¥ –ø—Ä–∏ close)
for value := range ch {
    // –æ–±—Ä–∞–±–æ—Ç–∫–∞
}

// –í—Ä—É—á–Ω—É—é —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π
for {
    value, ok := <-ch
    if !ok {
        break
    }
    // –æ–±—Ä–∞–±–æ—Ç–∫–∞
}
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —á–∏—Å–µ–ª

```go
package main

import "fmt"

func counter(max int) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        for i := 1; i <= max; i++ {
            ch <- i
        }
    }()
    
    return ch
}

func main() {
    for num := range counter(5) {
        fmt.Println(num)
    }
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Ñ–∞–∫—Ç–æ—Ä–∏–∞–ª–æ–≤

```go
package main

import "fmt"

func factorials(n int) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        
        result := 1
        for i := 1; i <= n; i++ {
            result *= i
            ch <- result
        }
    }()
    
    return ch
}

func main() {
    fmt.Println("Factorials:")
    for f := range factorials(7) {
        fmt.Println(f)
    }
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –§–∏–±–æ–Ω–∞—á—á–∏

```go
package main

import "fmt"

func fibonacci(max int) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        
        a, b := 0, 1
        for a <= max {
            ch <- a
            a, b = b, a+b
        }
    }()
    
    return ch
}

func main() {
    fmt.Println("Fibonacci <= 100:")
    for f := range fibonacci(100) {
        fmt.Println(f)
    }
}
```

### Pipeline: –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä ‚Üí —Ñ–∏–ª—å—Ç—Ä ‚Üí –æ–±—Ä–∞–±–æ—Ç—á–∏–∫

```go
package main

import "fmt"

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–∏—Å–µ–ª
func gen(nums ...int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for _, n := range nums {
            out <- n
        }
    }()
    return out
}

// –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —á—ë—Ç–Ω—ã—Ö
func filterEven(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            if n%2 == 0 {
                out <- n
            }
        }
    }()
    return out
}

// –í–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ –∫–≤–∞–¥—Ä–∞—Ç
func square(in <-chan int) <-chan int {
    out := make(chan int)
    go func() {
        defer close(out)
        for n := range in {
            out <- n * n
        }
    }()
    return out
}

func main() {
    // Pipeline: gen -> filterEven -> square
    nums := gen(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    evens := filterEven(nums)
    squared := square(evens)
    
    for n := range squared {
        fmt.Println(n)  // 4, 16, 36, 64, 100
    }
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å –æ—Ç–º–µ–Ω–æ–π

```go
package main

import (
    "fmt"
    "time"
)

func infiniteCounter(done <-chan struct{}) <-chan int {
    ch := make(chan int)
    
    go func() {
        defer close(ch)
        
        i := 1
        for {
            select {
            case <-done:
                fmt.Println("Generator: cancelled")
                return
            case ch <- i:
                i++
            }
        }
    }()
    
    return ch
}

func main() {
    done := make(chan struct{})
    
    nums := infiniteCounter(done)
    
    // –ß–∏—Ç–∞–µ–º 5 —á–∏—Å–µ–ª
    for i := 0; i < 5; i++ {
        fmt.Println(<-nums)
    }
    
    // –û—Ç–º–µ–Ω—è–µ–º –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä
    close(done)
    
    time.Sleep(100 * time.Millisecond)
    fmt.Println("Done!")
}
```

### –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä –∏–∑ —Ñ–∞–π–ª–∞ (–∏–º–∏—Ç–∞—Ü–∏—è)

```go
package main

import (
    "fmt"
    "time"
)

type LogEntry struct {
    Time    string
    Level   string
    Message string
}

func readLogs() <-chan LogEntry {
    ch := make(chan LogEntry)
    
    go func() {
        defer close(ch)
        
        // –ò–º–∏—Ç–∞—Ü–∏—è —á—Ç–µ–Ω–∏—è –∏–∑ —Ñ–∞–π–ª–∞
        logs := []LogEntry{
            {"10:00:01", "INFO", "Server started"},
            {"10:00:02", "DEBUG", "Loading config"},
            {"10:00:05", "WARNING", "High memory usage"},
            {"10:00:10", "ERROR", "Connection failed"},
        }
        
        for _, log := range logs {
            time.Sleep(100 * time.Millisecond)
            ch <- log
        }
    }()
    
    return ch
}

func main() {
    fmt.Println("Reading logs...")
    
    for log := range readLogs() {
        fmt.Printf("[%s] %s: %s\n", log.Time, log.Level, log.Message)
    }
    
    fmt.Println("All logs read!")
}
```

### Fan-Out: –Ω–µ—Å–∫–æ–ª—å–∫–æ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –æ–¥–Ω–æ–≥–æ –ø–æ—Ç–æ–∫–∞

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

func producer(n int) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 1; i <= n; i++ {
            ch <- i
        }
    }()
    return ch
}

func worker(id int, jobs <-chan int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    for job := range jobs {
        time.Sleep(50 * time.Millisecond)
        fmt.Printf("Worker %d processed job %d\n", id, job)
    }
}

func main() {
    jobs := producer(10)
    
    var wg sync.WaitGroup
    
    // Fan-Out: 3 –≤–æ—Ä–∫–µ—Ä–∞ —á–∏—Ç–∞—é—Ç –∏–∑ –æ–¥–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞
    for w := 1; w <= 3; w++ {
        wg.Add(1)
        go worker(w, jobs, &wg)
    }
    
    wg.Wait()
}
```

### –ë—É—Ñ–µ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ç–æ–∫

```go
package main

import (
    "fmt"
    "time"
)

func bufferedProducer(n, bufSize int) <-chan int {
    ch := make(chan int, bufSize)  // –±—É—Ñ–µ—Ä–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π!
    
    go func() {
        defer close(ch)
        
        for i := 1; i <= n; i++ {
            fmt.Printf("Producing: %d (buffer: %d/%d)\n", 
                i, len(ch), cap(ch))
            ch <- i
            time.Sleep(50 * time.Millisecond)
        }
    }()
    
    return ch
}

func main() {
    ch := bufferedProducer(10, 3)
    
    // –ú–µ–¥–ª–µ–Ω–Ω—ã–π –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª—å
    for n := range ch {
        time.Sleep(200 * time.Millisecond)
        fmt.Printf("  Consumed: %d\n", n)
    }
}
```

### –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: Word Count Pipeline

```go
package main

import (
    "fmt"
    "strings"
)

// –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å—Ç—Ä–æ–∫
func lines(text string) <-chan string {
    ch := make(chan string)
    go func() {
        defer close(ch)
        for _, line := range strings.Split(text, "\n") {
            if line != "" {
                ch <- line
            }
        }
    }()
    return ch
}

// –†–∞–∑–±–∏–≤–∫–∞ –Ω–∞ —Å–ª–æ–≤–∞
func words(in <-chan string) <-chan string {
    ch := make(chan string)
    go func() {
        defer close(ch)
        for line := range in {
            for _, word := range strings.Fields(line) {
                ch <- strings.ToLower(word)
            }
        }
    }()
    return ch
}

// –ü–æ–¥—Å—á—ë—Ç
func count(in <-chan string) <-chan map[string]int {
    ch := make(chan map[string]int)
    go func() {
        defer close(ch)
        counts := make(map[string]int)
        for word := range in {
            counts[word]++
        }
        ch <- counts
    }()
    return ch
}

func main() {
    text := `Hello World
Hello Go
Go is awesome
World of Go`

    // Pipeline: lines -> words -> count
    result := count(words(lines(text)))
    
    wordCounts := <-result
    
    for word, cnt := range wordCounts {
        fmt.Printf("%s: %d\n", word, cnt)
    }
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ó–∞–±—ã–ª–∏ –∑–∞–∫—Ä—ã—Ç—å –∫–∞–Ω–∞–ª

```go
func gen() <-chan int {
    ch := make(chan int)
    go func() {
        ch <- 1
        ch <- 2
        // ‚ùå –ó–∞–±—ã–ª–∏ close(ch)
    }()
    return ch
}

// for-range –∑–∞–≤–∏—Å–Ω–µ—Ç –Ω–∞–≤—Å–µ–≥–¥–∞
for v := range gen() {
    fmt.Println(v)
}
```

### 2. –ó–∞–∫—Ä—ã—Ç–∏–µ –∫–∞–Ω–∞–ª–∞ –ø–æ–ª—É—á–∞—Ç–µ–ª–µ–º

```go
// ‚ùå –ü–æ–ª—É—á–∞—Ç–µ–ª—å –∑–∞–∫—Ä—ã–≤–∞–µ—Ç ‚Äî –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—å –º–æ–∂–µ—Ç –ø–∞–Ω–∏–∫–æ–≤–∞—Ç—å
func consumer(ch chan int) {
    for v := range ch {
        fmt.Println(v)
    }
    close(ch)  // ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û!
}
```

### 3. –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–º–µ–Ω—ã

```go
// ‚ùå –ì–æ—Ä—É—Ç–∏–Ω–∞ –Ω–µ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –æ—Ç–º–µ–Ω—É
func gen(done <-chan struct{}) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; ; i++ {
            ch <- i  // –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –µ—Å–ª–∏ –Ω–∏–∫—Ç–æ –Ω–µ —á–∏—Ç–∞–µ—Ç!
        }
    }()
    return ch
}

// ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º done
func genCorrect(done <-chan struct{}) <-chan int {
    ch := make(chan int)
    go func() {
        defer close(ch)
        for i := 0; ; i++ {
            select {
            case <-done:
                return
            case ch <- i:
            }
        }
    }()
    return ch
}
```

---

## üèãÔ∏è –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è

### –ó–∞–¥–∞–Ω–∏–µ 1: time.Now

–ü–æ–ª—É—á–∏—Ç–µ —Ç–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ø–æ–ª—É—á–µ–Ω–æ: true
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    now := time.Now()
    fmt.Println("–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ø–æ–ª—É—á–µ–Ω–æ:", !now.IsZero())
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–¢–µ–∫—É—â–µ–µ –≤—Ä–µ–º—è –ø–æ–ª—É—á–µ–Ω–æ: true
```

**–ë–∞–ª–ª—ã:** 5

### –ó–∞–¥–∞–Ω–∏–µ 2: time.Parse

–†–∞—Å–ø–∞—Ä—Å–∏—Ç–µ —Å—Ç—Ä–æ–∫—É –≤ –≤—Ä–µ–º—è.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–ì–æ–¥: 2024
–ú–µ—Å—è—Ü: January
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    t, _ := time.Parse("2006-01-02", "2024-01-15")
    fmt.Println("–ì–æ–¥:", t.Year())
    fmt.Println("–ú–µ—Å—è—Ü:", t.Month())
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–ì–æ–¥: 2024
–ú–µ—Å—è—Ü: January
```

**–ë–∞–ª–ª—ã:** 15

### –ó–∞–¥–∞–Ω–∏–µ 3: time.Format

–û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–π—Ç–µ –≤—Ä–µ–º—è –≤ —Å—Ç—Ä–æ–∫—É.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–§–æ—Ä–º–∞—Ç 1: 15.01.2024
–§–æ—Ä–º–∞—Ç 2: 2024/01/15
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    t, _ := time.Parse("2006-01-02", "2024-01-15")
    fmt.Println("–§–æ—Ä–º–∞—Ç 1:", t.Format("02.01.2006"))
    fmt.Println("–§–æ—Ä–º–∞—Ç 2:", t.Format("2006/01/02"))
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–§–æ—Ä–º–∞—Ç 1: 15.01.2024
–§–æ—Ä–º–∞—Ç 2: 2024/01/15
```

**–ë–∞–ª–ª—ã:** 15

### –ó–∞–¥–∞–Ω–∏–µ 4: time.Duration

–†–∞–±–æ—Ç–∞ —Å –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å—é.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
1 —á–∞—Å 30 –º–∏–Ω—É—Ç = 1h30m0s
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "time"
)

func main() {
    d := 1*time.Hour + 30*time.Minute
    fmt.Println("1 —á–∞—Å 30 –º–∏–Ω—É—Ç =", d)
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
1 —á–∞—Å 30 –º–∏–Ω—É—Ç = 1h30m0s
```

**–ë–∞–ª–ª—ã:** 10

### –ó–∞–¥–∞–Ω–∏–µ 5: time.Add –∏ Sub

–î–æ–±–∞–≤—å—Ç–µ –∏ –≤—ã—á—Ç–∏—Ç–µ –≤—Ä–µ–º—è.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
+1 –¥–µ–Ω—å: 16
-1 –¥–µ–Ω—å: 14
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "time"
)

// TODO: –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–µ—à–µ–Ω–∏–µ

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
+1 –¥–µ–Ω—å: 16
-1 –¥–µ–Ω—å: 14
```

**–ë–∞–ª–ª—ã:** 15
