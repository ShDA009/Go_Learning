# –ú—å—é—Ç–µ–∫—Å—ã (Mutex)

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **–ú—å—é—Ç–µ–∫—Å** ‚Äî –º–µ—Ö–∞–Ω–∏–∑–º –≤–∑–∞–∏–º–Ω–æ–≥–æ –∏—Å–∫–ª—é—á–µ–Ω–∏—è (mutual exclusion)
2. **sync.Mutex** ‚Äî –±–∞–∑–æ–≤—ã–π –º—å—é—Ç–µ–∫—Å (Lock/Unlock)
3. **sync.RWMutex** ‚Äî –º—å—é—Ç–µ–∫—Å –¥–ª—è —á—Ç–µ–Ω–∏—è/–∑–∞–ø–∏—Å–∏ (–º–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π, –æ–¥–∏–Ω –ø–∏—Å–∞—Ç–µ–ª—å)
4. **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è** ‚Äî –∫–æ–¥ –º–µ–∂–¥—É Lock –∏ Unlock
5. **defer Unlock** ‚Äî –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –º—å—é—Ç–µ–∫—Å–∞
6. **–ü–µ—Ä–µ–¥–∞—á–∞ –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é** ‚Äî –º—å—é—Ç–µ–∫—Å –Ω–µ–ª—å–∑—è –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å

---

## üìñ –¢–µ–æ—Ä–∏—è

### –ß—Ç–æ —Ç–∞–∫–æ–µ –º—å—é—Ç–µ–∫—Å?

**–ú—å—é—Ç–µ–∫—Å (mutex)** ‚Äî –æ—Ç "mutual exclusion" (–≤–∑–∞–∏–º–Ω–æ–µ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ). –≠—Ç–æ –∑–∞–º–æ–∫, –∫–æ—Ç–æ—Ä—ã–π –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç: —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –≥–æ—Ä—É—Ç–∏–Ω–∞ –º–æ–∂–µ—Ç –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞—â–∏—â—ë–Ω–Ω—ã–π –∫–æ–¥ –≤ –ª—é–±–æ–π –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏.

```go
var mu sync.Mutex

mu.Lock()   // –∑–∞–∫—Ä—ã—Ç—å –∑–∞–º–æ–∫
// –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è ‚Äî –∑–¥–µ—Å—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –≥–æ—Ä—É—Ç–∏–Ω–∞
mu.Unlock() // –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–º–æ–∫
```

### –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è

–ö–æ–¥ –º–µ–∂–¥—É `Lock()` –∏ `Unlock()` –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è **–∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π —Å–µ–∫—Ü–∏–µ–π**:

```go
mu.Lock()
// === –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –°–ï–ö–¶–ò–Ø ===
balance += amount
transactions++
// === –ö–û–ù–ï–¶ –ö–†–ò–¢–ò–ß–ï–°–ö–û–ô –°–ï–ö–¶–ò–ò ===
mu.Unlock()
```

–ï—Å–ª–∏ –≥–æ—Ä—É—Ç–∏–Ω–∞ A –¥–µ—Ä–∂–∏—Ç –∑–∞–º–æ–∫, –≥–æ—Ä—É—Ç–∏–Ω–∞ B –±—É–¥–µ—Ç **–∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–∞** –Ω–∞ `Lock()` –ø–æ–∫–∞ A –Ω–µ –≤—ã–∑–æ–≤–µ—Ç `Unlock()`.

### –í—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ defer!

```go
// –ü–õ–û–•–û ‚Äî –ª–µ–≥–∫–æ –∑–∞–±—ã—Ç—å Unlock
mu.Lock()
if condition {
    return  // –£–ø—Å! Unlock –Ω–µ –≤—ã–∑–≤–∞–Ω = –¥–µ–¥–ª–æ–∫!
}
mu.Unlock()

// –•–û–†–û–®–û ‚Äî defer –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç Unlock
mu.Lock()
defer mu.Unlock()
if condition {
    return  // Unlock –≤—ã–∑–æ–≤–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
}
```

### sync.Mutex vs sync.RWMutex

| –¢–∏–ø | Lock | Unlock | –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å |
|-----|------|--------|-------------|
| `Mutex` | –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–π | –û–¥–∏–Ω –≤–ª–∞–¥–µ–ª–µ—Ü | –ü—Ä–æ—Å—Ç–æ–π |
| `RWMutex` | –î–ª—è –∑–∞–ø–∏—Å–∏ | + RLock/RUnlock –¥–ª—è —á—Ç–µ–Ω–∏—è | –ú–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π |

### RWMutex ‚Äî –∫–æ–≥–¥–∞ –º–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π

```go
var rwmu sync.RWMutex
var cache map[string]string

// –ß—Ç–µ–Ω–∏–µ ‚Äî –º–Ω–æ–≥–æ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ
func get(key string) string {
    rwmu.RLock()
    defer rwmu.RUnlock()
    return cache[key]
}

// –ó–∞–ø–∏—Å—å ‚Äî —Ç–æ–ª—å–∫–æ –æ–¥–Ω–∞ –≥–æ—Ä—É—Ç–∏–Ω–∞
func set(key, value string) {
    rwmu.Lock()
    defer rwmu.Unlock()
    cache[key] = value
}
```

### –ú—å—é—Ç–µ–∫—Å –Ω–µ–ª—å–∑—è –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å!

```go
type SafeCounter struct {
    mu sync.Mutex
    count int
}

// –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –∫–æ–ø–∏—Ä—É–µ—Ç—Å—è –≤–º–µ—Å—Ç–µ —Å –º—å—é—Ç–µ–∫—Å–æ–º!
func (c SafeCounter) Value() int {
    c.mu.Lock()  // –±–ª–æ–∫–∏—Ä—É–µ–º –∫–æ–ø–∏—é –º—å—é—Ç–µ–∫—Å–∞
    defer c.mu.Unlock()
    return c.count
}

// –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—å
func (c *SafeCounter) Value() int {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.count
}
```

### –î–µ–¥–ª–æ–∫ (Deadlock)

–°–∏—Ç—É–∞—Ü–∏—è, –∫–æ–≥–¥–∞ –≥–æ—Ä—É—Ç–∏–Ω—ã –∂–¥—É—Ç –¥—Ä—É–≥ –¥—Ä—É–≥–∞ –≤–µ—á–Ω–æ:

```go
// –î–ï–î–õ–û–ö!
mu.Lock()
mu.Lock()  // –ñ–¥—ë–º –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è... —Å–µ–±—è —Å–∞–º–æ–≥–æ

// –î–ï–î–õ–û–ö –º–µ–∂–¥—É –≥–æ—Ä—É—Ç–∏–Ω–∞–º–∏
// –ì–æ—Ä—É—Ç–∏–Ω–∞ 1: Lock(A), –∑–∞—Ç–µ–º Lock(B)
// –ì–æ—Ä—É—Ç–∏–Ω–∞ 2: Lock(B), –∑–∞—Ç–µ–º Lock(A)
```

**–ü—Ä–∞–≤–∏–ª–æ:** –í—Å–µ–≥–¥–∞ –∑–∞—Ö–≤–∞—Ç—ã–≤–∞–π—Ç–µ –º—å—é—Ç–µ–∫—Å—ã –≤ –æ–¥–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ!

### –ú—å—é—Ç–µ–∫—Å vs –ö–∞–Ω–∞–ª—ã

–ú–∞–Ω—Ç—Ä–∞ Go: "Don't communicate by sharing memory; share memory by communicating."

| –ú—å—é—Ç–µ–∫—Å—ã | –ö–∞–Ω–∞–ª—ã |
|----------|--------|
| –ó–∞—â–∏—Ç–∞ –¥–∞–Ω–Ω—ã—Ö | –ü–µ—Ä–µ–¥–∞—á–∞ –¥–∞–Ω–Ω—ã—Ö |
| –ü—Ä–æ—Å—Ç—ã–µ —Å–ª—É—á–∞–∏ | –°–ª–æ–∂–Ω–∞—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ü–∏—è |
| –ú–µ–Ω—å—à–µ –Ω–∞–∫–ª–∞–¥–Ω—ã—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤ | –ë–æ–ª–µ–µ –∏–¥–∏–æ–º–∞—Ç–∏—á–Ω–æ |

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### sync.Mutex

```go
var mu sync.Mutex

mu.Lock()
// –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
mu.Unlock()

// –ò–ª–∏ —Å defer
mu.Lock()
defer mu.Unlock()
// –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
```

### sync.RWMutex

```go
var rwmu sync.RWMutex

// –î–ª—è –∑–∞–ø–∏—Å–∏ (—ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ)
rwmu.Lock()
// –∑–∞–ø–∏—Å—å
rwmu.Unlock()

// –î–ª—è —á—Ç–µ–Ω–∏—è (—Ä–∞–∑–¥–µ–ª—è–µ–º–æ)
rwmu.RLock()
// —á—Ç–µ–Ω–∏–µ
rwmu.RUnlock()
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ë–∞–∑–æ–≤—ã–π Mutex

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mu      sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    
    for i := 0; i < 1000; i++ {
        mu.Lock()
        counter++
        mu.Unlock()
    }
}

func main() {
    var wg sync.WaitGroup
    
    wg.Add(3)
    go increment(&wg)
    go increment(&wg)
    go increment(&wg)
    
    wg.Wait()
    fmt.Println("Counter:", counter)  // 3000
}
```

### Mutex —Å defer

```go
package main

import (
    "fmt"
    "sync"
)

type BankAccount struct {
    mu      sync.Mutex
    balance float64
}

func (a *BankAccount) Deposit(amount float64) {
    a.mu.Lock()
    defer a.mu.Unlock()  // ‚úÖ –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –æ—Å–≤–æ–±–æ–¥–∏—Ç—Å—è
    
    if amount <= 0 {
        return  // Unlock –≤—ã–∑–æ–≤–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    }
    
    a.balance += amount
}

func (a *BankAccount) Withdraw(amount float64) bool {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if amount > a.balance {
        return false
    }
    
    a.balance -= amount
    return true
}

func (a *BankAccount) Balance() float64 {
    a.mu.Lock()
    defer a.mu.Unlock()
    return a.balance
}

func main() {
    account := &BankAccount{balance: 1000}
    var wg sync.WaitGroup
    
    // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
    for i := 0; i < 10; i++ {
        wg.Add(2)
        go func() {
            defer wg.Done()
            account.Deposit(100)
        }()
        go func() {
            defer wg.Done()
            account.Withdraw(50)
        }()
    }
    
    wg.Wait()
    fmt.Printf("Final balance: %.2f\n", account.Balance())
}
```

### RWMutex ‚Äî –º–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Cache struct {
    mu   sync.RWMutex
    data map[string]string
}

func NewCache() *Cache {
    return &Cache{data: make(map[string]string)}
}

func (c *Cache) Set(key, value string) {
    c.mu.Lock()          // –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
    defer c.mu.Unlock()
    
    fmt.Printf("Writing: %s = %s\n", key, value)
    c.data[key] = value
}

func (c *Cache) Get(key string) (string, bool) {
    c.mu.RLock()         // –†–∞–∑–¥–µ–ª—è–µ–º–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
    defer c.mu.RUnlock()
    
    value, ok := c.data[key]
    return value, ok
}

func main() {
    cache := NewCache()
    var wg sync.WaitGroup
    
    // 1 –ø–∏—Å–∞—Ç–µ–ª—å
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            cache.Set("key", fmt.Sprintf("value-%d", i))
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // 5 —á–∏—Ç–∞—Ç–µ–ª–µ–π (–º–æ–≥—É—Ç —á–∏—Ç–∞—Ç—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)
    for r := 0; r < 5; r++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for i := 0; i < 10; i++ {
                if val, ok := cache.Get("key"); ok {
                    fmt.Printf("Reader %d: %s\n", id, val)
                }
                time.Sleep(50 * time.Millisecond)
            }
        }(r)
    }
    
    wg.Wait()
}
```

### –í—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ –º—å—é—Ç–µ–∫—Å–∞ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É

```go
package main

import (
    "fmt"
    "sync"
)

type SafeMap struct {
    sync.RWMutex  // –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{data: make(map[string]int)}
}

func (m *SafeMap) Set(key string, value int) {
    m.Lock()        // –≤—ã–∑—ã–≤–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é
    defer m.Unlock()
    m.data[key] = value
}

func (m *SafeMap) Get(key string) (int, bool) {
    m.RLock()
    defer m.RUnlock()
    val, ok := m.data[key]
    return val, ok
}

func (m *SafeMap) Inc(key string) {
    m.Lock()
    defer m.Unlock()
    m.data[key]++
}

func main() {
    sm := NewSafeMap()
    var wg sync.WaitGroup
    
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            sm.Inc("counter")
        }()
    }
    
    wg.Wait()
    val, _ := sm.Get("counter")
    fmt.Println("Counter:", val)  // 100
}
```

### –ó–∞—â–∏—Ç–∞ —Å–ª–æ–∂–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```go
package main

import (
    "fmt"
    "sync"
)

type User struct {
    ID    int
    Name  string
    Score int
}

type UserStore struct {
    mu    sync.RWMutex
    users map[int]*User
}

func NewUserStore() *UserStore {
    return &UserStore{users: make(map[int]*User)}
}

func (s *UserStore) Add(user *User) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.users[user.ID] = user
}

func (s *UserStore) Get(id int) (*User, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    user, ok := s.users[id]
    if !ok {
        return nil, false
    }
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é!
    copy := *user
    return &copy, true
}

func (s *UserStore) UpdateScore(id, delta int) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    user, ok := s.users[id]
    if !ok {
        return false
    }
    user.Score += delta
    return true
}

func (s *UserStore) List() []*User {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    result := make([]*User, 0, len(s.users))
    for _, u := range s.users {
        copy := *u
        result = append(result, &copy)
    }
    return result
}

func main() {
    store := NewUserStore()
    var wg sync.WaitGroup
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    for i := 1; i <= 5; i++ {
        store.Add(&User{ID: i, Name: fmt.Sprintf("User%d", i), Score: 0})
    }
    
    // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            store.UpdateScore(1, 1)
        }()
    }
    
    wg.Wait()
    
    user, _ := store.Get(1)
    fmt.Printf("User 1 score: %d\n", user.Score)  // 100
}
```

### TryLock (Go 1.18+)

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var mu sync.Mutex

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    if mu.TryLock() {  // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        defer mu.Unlock()
        
        fmt.Printf("Worker %d: got lock\n", id)
        time.Sleep(100 * time.Millisecond)
    } else {
        fmt.Printf("Worker %d: lock busy, skipping\n", id)
    }
}

func main() {
    var wg sync.WaitGroup
    
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    
    wg.Wait()
}
```

### –ò–∑–±–µ–≥–∞–µ–º deadlock

```go
package main

import (
    "fmt"
    "sync"
)

// ‚ùå DEADLOCK ‚Äî –Ω–µ—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
func deadlock() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup
    
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        mu1.Lock()
        // time.Sleep(1 * time.Millisecond)
        mu2.Lock()  // –ñ–¥—ë—Ç mu2, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–æ–π –≥–æ—Ä—É—Ç–∏–Ω–æ–π
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        defer wg.Done()
        mu2.Lock()
        // time.Sleep(1 * time.Millisecond)
        mu1.Lock()  // –ñ–¥—ë—Ç mu1, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–æ–π –≥–æ—Ä—É—Ç–∏–Ω–æ–π
        mu1.Unlock()
        mu2.Unlock()
    }()
    
    wg.Wait()
}

// ‚úÖ –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
func noDeadlock() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup
    
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        mu1.Lock()  // –í—Å–µ–≥–¥–∞ mu1 –ø–µ—Ä–≤—ã–º
        mu2.Lock()
        fmt.Println("Goroutine 1")
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        defer wg.Done()
        mu1.Lock()  // –í—Å–µ–≥–¥–∞ mu1 –ø–µ—Ä–≤—ã–º
        mu2.Lock()
        fmt.Println("Goroutine 2")
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    wg.Wait()
}

func main() {
    noDeadlock()
    fmt.Println("Done!")
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –º—å—é—Ç–µ–∫—Å–∞

```go
type Counter struct {
    mu    sync.Mutex
    value int
}

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –º—å—é—Ç–µ–∫—Å–æ–º
func process(c Counter) {
    c.mu.Lock()  // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–æ–ø–∏—é!
    c.value++
    c.mu.Unlock()
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî —É–∫–∞–∑–∞—Ç–µ–ª—å
func process(c *Counter) {
    c.mu.Lock()
    c.value++
    c.mu.Unlock()
}
```

### 2. Unlock –±–µ–∑ Lock

```go
var mu sync.Mutex

// ‚ùå PANIC
mu.Unlock()  // fatal error: sync: unlock of unlocked mutex

// ‚úÖ –í—Å–µ–≥–¥–∞ –ø–∞—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
mu.Lock()
// —Ä–∞–±–æ—Ç–∞
mu.Unlock()
```

### 3. Deadlock ‚Äî —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞

```go
var mu sync.Mutex

func outer() {
    mu.Lock()
    defer mu.Unlock()
    inner()  // ‚ùå DEADLOCK
}

func inner() {
    mu.Lock()  // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —É–∂–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
    defer mu.Unlock()
}

// ‚úÖ –†–µ—à–µ–Ω–∏–µ: –æ—Ç–¥–µ–ª—å–Ω—ã–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
func outer() {
    mu.Lock()
    defer mu.Unlock()
    innerLocked()
}

func innerLocked() {
    // —Ä–∞–±–æ—Ç–∞ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
}
```

### 4. –ó–∞–±—ã–ª–∏ Unlock

```go
func process() {
    mu.Lock()
    
    if err != nil {
        return  // ‚ùå Unlock –Ω–µ –≤—ã–∑–≤–∞–Ω!
    }
    
    mu.Unlock()
}

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ defer
func process() {
    mu.Lock()
    defer mu.Unlock()
    
    if err != nil {
        return  // Unlock –≤—ã–∑–æ–≤–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    }
}
```

### 5. –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è

```go
// ‚ùå –ë–ª–æ–∫–∏—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ
func process() {
    mu.Lock()
    defer mu.Unlock()
    
    result := heavyComputation()  // –î–æ–ª–≥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π
    data[key] = result
}

// ‚úÖ –ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫—É—é —Å–µ–∫—Ü–∏—é
func process() {
    result := heavyComputation()  // –í–Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    
    mu.Lock()
    data[key] = result  // –¢–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º
    mu.Unlock()
}
```

---

## üèãÔ∏è –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è

### –ó–∞–¥–∞–Ω–∏–µ 1: sort.Ints

–û—Ç—Å–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Å—Ä–µ–∑ int.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: [1 2 3 5 8]
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    nums := []int{3, 1, 5, 2, 8}
    sort.Ints(nums)
    fmt.Println("–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ:", nums)
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: [1 2 3 5 8]
```

**–ë–∞–ª–ª—ã:** 5

### –ó–∞–¥–∞–Ω–∏–µ 2: sort.Strings

–û—Ç—Å–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Å—Ä–µ–∑ —Å—Ç—Ä–æ–∫.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: [apple banana cherry]
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    words := []string{"banana", "cherry", "apple"}
    sort.Strings(words)
    fmt.Println("–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ:", words)
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: [apple banana cherry]
```

**–ë–∞–ª–ª—ã:** 5

### –ó–∞–¥–∞–Ω–∏–µ 3: sort.Slice

–û—Ç—Å–æ—Ä—Ç–∏—Ä—É–π—Ç–µ —Å—Ä–µ–∑ –ø–æ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–º—É –∫—Ä–∏—Ç–µ—Ä–∏—é.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–ü–æ –≤–æ–∑—Ä–∞—Å—Ç—É: [{Alice 25} {Bob 30} {Charlie 20}]
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import "fmt"

// TODO: –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–µ—à–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–¥–∞–Ω–∏—é

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–ü–æ –≤–æ–∑—Ä–∞—Å—Ç—É: [{Charlie 20} {Alice 25} {Bob 30}]
```

**–ë–∞–ª–ª—ã:** 15

### –ó–∞–¥–∞–Ω–∏–µ 4: sort.Search

–ù–∞–π–¥–∏—Ç–µ —ç–ª–µ–º–µ–Ω—Ç –±–∏–Ω–∞—Ä–Ω—ã–º –ø–æ–∏—Å–∫–æ–º.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–ò–Ω–¥–µ–∫—Å 5: 2
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import (
    "fmt"
    "sort"
)

func main() {
    nums := []int{1, 3, 5, 7, 9}
    idx := sort.Search(len(nums), func(i int) bool {
        return nums[i] >= 5
    })
    fmt.Println("–ò–Ω–¥–µ–∫—Å 5:", idx)
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–ò–Ω–¥–µ–∫—Å 5: 2
```

**–ë–∞–ª–ª—ã:** 15

### –ó–∞–¥–∞–Ω–∏–µ 5: sort.Interface

–†–µ–∞–ª–∏–∑—É–π—Ç–µ sort.Interface –¥–ª—è —Å–≤–æ–µ–≥–æ —Ç–∏–ø–∞.

**–û–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç:**
```
–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: [a bb ccc]
```

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import "fmt"

// TODO: –û–ø—Ä–µ–¥–µ–ª–∏—Ç–µ –∏ —Ä–µ–∞–ª–∏–∑—É–π—Ç–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
–û—Ç—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–æ: [a bb ccc]
```

**–ë–∞–ª–ª—ã:** 20
