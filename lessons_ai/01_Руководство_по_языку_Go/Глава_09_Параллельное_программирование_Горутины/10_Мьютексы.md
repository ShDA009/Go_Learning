# –ú—å—é—Ç–µ–∫—Å—ã (Mutex)

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **–ú—å—é—Ç–µ–∫—Å** ‚Äî –º–µ—Ö–∞–Ω–∏–∑–º –≤–∑–∞–∏–º–Ω–æ–≥–æ –∏—Å–∫–ª—é—á–µ–Ω–∏—è (mutual exclusion)
2. **sync.Mutex** ‚Äî –±–∞–∑–æ–≤—ã–π –º—å—é—Ç–µ–∫—Å (Lock/Unlock)
3. **sync.RWMutex** ‚Äî –º—å—é—Ç–µ–∫—Å –¥–ª—è —á—Ç–µ–Ω–∏—è/–∑–∞–ø–∏—Å–∏ (–º–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π, –æ–¥–∏–Ω –ø–∏—Å–∞—Ç–µ–ª—å)
4. **–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è** ‚Äî –∫–æ–¥ –º–µ–∂–¥—É Lock –∏ Unlock
5. **defer Unlock** ‚Äî –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –º—å—é—Ç–µ–∫—Å–∞
6. **–ü–µ—Ä–µ–¥–∞—á–∞ –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é** ‚Äî –º—å—é—Ç–µ–∫—Å –Ω–µ–ª—å–∑—è –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### sync.Mutex

```go
var mu sync.Mutex

mu.Lock()
// –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
mu.Unlock()

// –ò–ª–∏ —Å defer
mu.Lock()
defer mu.Unlock()
// –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è
```

### sync.RWMutex

```go
var rwmu sync.RWMutex

// –î–ª—è –∑–∞–ø–∏—Å–∏ (—ç–∫—Å–∫–ª—é–∑–∏–≤–Ω–æ)
rwmu.Lock()
// –∑–∞–ø–∏—Å—å
rwmu.Unlock()

// –î–ª—è —á—Ç–µ–Ω–∏—è (—Ä–∞–∑–¥–µ–ª—è–µ–º–æ)
rwmu.RLock()
// —á—Ç–µ–Ω–∏–µ
rwmu.RUnlock()
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ë–∞–∑–æ–≤—ã–π Mutex

```go
package main

import (
    "fmt"
    "sync"
)

var (
    counter int
    mu      sync.Mutex
)

func increment(wg *sync.WaitGroup) {
    defer wg.Done()
    
    for i := 0; i < 1000; i++ {
        mu.Lock()
        counter++
        mu.Unlock()
    }
}

func main() {
    var wg sync.WaitGroup
    
    wg.Add(3)
    go increment(&wg)
    go increment(&wg)
    go increment(&wg)
    
    wg.Wait()
    fmt.Println("Counter:", counter)  // 3000
}
```

### Mutex —Å defer

```go
package main

import (
    "fmt"
    "sync"
)

type BankAccount struct {
    mu      sync.Mutex
    balance float64
}

func (a *BankAccount) Deposit(amount float64) {
    a.mu.Lock()
    defer a.mu.Unlock()  // ‚úÖ –ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –æ—Å–≤–æ–±–æ–¥–∏—Ç—Å—è
    
    if amount <= 0 {
        return  // Unlock –≤—ã–∑–æ–≤–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    }
    
    a.balance += amount
}

func (a *BankAccount) Withdraw(amount float64) bool {
    a.mu.Lock()
    defer a.mu.Unlock()
    
    if amount > a.balance {
        return false
    }
    
    a.balance -= amount
    return true
}

func (a *BankAccount) Balance() float64 {
    a.mu.Lock()
    defer a.mu.Unlock()
    return a.balance
}

func main() {
    account := &BankAccount{balance: 1000}
    var wg sync.WaitGroup
    
    // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
    for i := 0; i < 10; i++ {
        wg.Add(2)
        go func() {
            defer wg.Done()
            account.Deposit(100)
        }()
        go func() {
            defer wg.Done()
            account.Withdraw(50)
        }()
    }
    
    wg.Wait()
    fmt.Printf("Final balance: %.2f\n", account.Balance())
}
```

### RWMutex ‚Äî –º–Ω–æ–≥–æ —á–∏—Ç–∞—Ç–µ–ª–µ–π

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type Cache struct {
    mu   sync.RWMutex
    data map[string]string
}

func NewCache() *Cache {
    return &Cache{data: make(map[string]string)}
}

func (c *Cache) Set(key, value string) {
    c.mu.Lock()          // –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
    defer c.mu.Unlock()
    
    fmt.Printf("Writing: %s = %s\n", key, value)
    c.data[key] = value
}

func (c *Cache) Get(key string) (string, bool) {
    c.mu.RLock()         // –†–∞–∑–¥–µ–ª—è–µ–º–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞
    defer c.mu.RUnlock()
    
    value, ok := c.data[key]
    return value, ok
}

func main() {
    cache := NewCache()
    var wg sync.WaitGroup
    
    // 1 –ø–∏—Å–∞—Ç–µ–ª—å
    wg.Add(1)
    go func() {
        defer wg.Done()
        for i := 0; i < 5; i++ {
            cache.Set("key", fmt.Sprintf("value-%d", i))
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // 5 —á–∏—Ç–∞—Ç–µ–ª–µ–π (–º–æ–≥—É—Ç —á–∏—Ç–∞—Ç—å –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ)
    for r := 0; r < 5; r++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()
            for i := 0; i < 10; i++ {
                if val, ok := cache.Get("key"); ok {
                    fmt.Printf("Reader %d: %s\n", id, val)
                }
                time.Sleep(50 * time.Millisecond)
            }
        }(r)
    }
    
    wg.Wait()
}
```

### –í—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ –º—å—é—Ç–µ–∫—Å–∞ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä—É

```go
package main

import (
    "fmt"
    "sync"
)

type SafeMap struct {
    sync.RWMutex  // –≤—Å—Ç—Ä–∞–∏–≤–∞–Ω–∏–µ
    data map[string]int
}

func NewSafeMap() *SafeMap {
    return &SafeMap{data: make(map[string]int)}
}

func (m *SafeMap) Set(key string, value int) {
    m.Lock()        // –≤—ã–∑—ã–≤–∞–µ–º –Ω–∞–ø—Ä—è–º—É—é
    defer m.Unlock()
    m.data[key] = value
}

func (m *SafeMap) Get(key string) (int, bool) {
    m.RLock()
    defer m.RUnlock()
    val, ok := m.data[key]
    return val, ok
}

func (m *SafeMap) Inc(key string) {
    m.Lock()
    defer m.Unlock()
    m.data[key]++
}

func main() {
    sm := NewSafeMap()
    var wg sync.WaitGroup
    
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            sm.Inc("counter")
        }()
    }
    
    wg.Wait()
    val, _ := sm.Get("counter")
    fmt.Println("Counter:", val)  // 100
}
```

### –ó–∞—â–∏—Ç–∞ —Å–ª–æ–∂–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

```go
package main

import (
    "fmt"
    "sync"
)

type User struct {
    ID    int
    Name  string
    Score int
}

type UserStore struct {
    mu    sync.RWMutex
    users map[int]*User
}

func NewUserStore() *UserStore {
    return &UserStore{users: make(map[int]*User)}
}

func (s *UserStore) Add(user *User) {
    s.mu.Lock()
    defer s.mu.Unlock()
    s.users[user.ID] = user
}

func (s *UserStore) Get(id int) (*User, bool) {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    user, ok := s.users[id]
    if !ok {
        return nil, false
    }
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é!
    copy := *user
    return &copy, true
}

func (s *UserStore) UpdateScore(id, delta int) bool {
    s.mu.Lock()
    defer s.mu.Unlock()
    
    user, ok := s.users[id]
    if !ok {
        return false
    }
    user.Score += delta
    return true
}

func (s *UserStore) List() []*User {
    s.mu.RLock()
    defer s.mu.RUnlock()
    
    result := make([]*User, 0, len(s.users))
    for _, u := range s.users {
        copy := *u
        result = append(result, &copy)
    }
    return result
}

func main() {
    store := NewUserStore()
    var wg sync.WaitGroup
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
    for i := 1; i <= 5; i++ {
        store.Add(&User{ID: i, Name: fmt.Sprintf("User%d", i), Score: 0})
    }
    
    // –ü–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            store.UpdateScore(1, 1)
        }()
    }
    
    wg.Wait()
    
    user, _ := store.Get(1)
    fmt.Printf("User 1 score: %d\n", user.Score)  // 100
}
```

### TryLock (Go 1.18+)

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

var mu sync.Mutex

func worker(id int, wg *sync.WaitGroup) {
    defer wg.Done()
    
    if mu.TryLock() {  // –ü–æ–ø—ã—Ç–∫–∞ –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
        defer mu.Unlock()
        
        fmt.Printf("Worker %d: got lock\n", id)
        time.Sleep(100 * time.Millisecond)
    } else {
        fmt.Printf("Worker %d: lock busy, skipping\n", id)
    }
}

func main() {
    var wg sync.WaitGroup
    
    for i := 1; i <= 5; i++ {
        wg.Add(1)
        go worker(i, &wg)
    }
    
    wg.Wait()
}
```

### –ò–∑–±–µ–≥–∞–µ–º deadlock

```go
package main

import (
    "fmt"
    "sync"
)

// ‚ùå DEADLOCK ‚Äî –Ω–µ—Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
func deadlock() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup
    
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        mu1.Lock()
        // time.Sleep(1 * time.Millisecond)
        mu2.Lock()  // –ñ–¥—ë—Ç mu2, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–æ–π –≥–æ—Ä—É—Ç–∏–Ω–æ–π
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        defer wg.Done()
        mu2.Lock()
        // time.Sleep(1 * time.Millisecond)
        mu1.Lock()  // –ñ–¥—ë—Ç mu1, –∫–æ—Ç–æ—Ä–∞—è –∑–∞–Ω—è—Ç–∞ –¥—Ä—É–≥–æ–π –≥–æ—Ä—É—Ç–∏–Ω–æ–π
        mu1.Unlock()
        mu2.Unlock()
    }()
    
    wg.Wait()
}

// ‚úÖ –§–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
func noDeadlock() {
    var mu1, mu2 sync.Mutex
    var wg sync.WaitGroup
    
    wg.Add(2)
    
    go func() {
        defer wg.Done()
        mu1.Lock()  // –í—Å–µ–≥–¥–∞ mu1 –ø–µ—Ä–≤—ã–º
        mu2.Lock()
        fmt.Println("Goroutine 1")
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    go func() {
        defer wg.Done()
        mu1.Lock()  // –í—Å–µ–≥–¥–∞ mu1 –ø–µ—Ä–≤—ã–º
        mu2.Lock()
        fmt.Println("Goroutine 2")
        mu2.Unlock()
        mu1.Unlock()
    }()
    
    wg.Wait()
}

func main() {
    noDeadlock()
    fmt.Println("Done!")
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –º—å—é—Ç–µ–∫—Å–∞

```go
type Counter struct {
    mu    sync.Mutex
    value int
}

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û ‚Äî –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã —Å –º—å—é—Ç–µ–∫—Å–æ–º
func process(c Counter) {
    c.mu.Lock()  // –ë–ª–æ–∫–∏—Ä—É–µ–º –∫–æ–ø–∏—é!
    c.value++
    c.mu.Unlock()
}

// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û ‚Äî —É–∫–∞–∑–∞—Ç–µ–ª—å
func process(c *Counter) {
    c.mu.Lock()
    c.value++
    c.mu.Unlock()
}
```

### 2. Unlock –±–µ–∑ Lock

```go
var mu sync.Mutex

// ‚ùå PANIC
mu.Unlock()  // fatal error: sync: unlock of unlocked mutex

// ‚úÖ –í—Å–µ–≥–¥–∞ –ø–∞—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏
mu.Lock()
// —Ä–∞–±–æ—Ç–∞
mu.Unlock()
```

### 3. Deadlock ‚Äî —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–∞—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∞

```go
var mu sync.Mutex

func outer() {
    mu.Lock()
    defer mu.Unlock()
    inner()  // ‚ùå DEADLOCK
}

func inner() {
    mu.Lock()  // –ü—ã—Ç–∞–µ–º—Å—è –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å —É–∂–µ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
    defer mu.Unlock()
}

// ‚úÖ –†–µ—à–µ–Ω–∏–µ: –æ—Ç–¥–µ–ª—å–Ω—ã–µ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
func outer() {
    mu.Lock()
    defer mu.Unlock()
    innerLocked()
}

func innerLocked() {
    // —Ä–∞–±–æ—Ç–∞ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
}
```

### 4. –ó–∞–±—ã–ª–∏ Unlock

```go
func process() {
    mu.Lock()
    
    if err != nil {
        return  // ‚ùå Unlock –Ω–µ –≤—ã–∑–≤–∞–Ω!
    }
    
    mu.Unlock()
}

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ defer
func process() {
    mu.Lock()
    defer mu.Unlock()
    
    if err != nil {
        return  // Unlock –≤—ã–∑–æ–≤–µ—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    }
}
```

### 5. –°–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è —Å–µ–∫—Ü–∏—è

```go
// ‚ùå –ë–ª–æ–∫–∏—Ä—É–µ–º —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ
func process() {
    mu.Lock()
    defer mu.Unlock()
    
    result := heavyComputation()  // –î–æ–ª–≥–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –ø–æ–¥ –±–ª–æ–∫–∏—Ä–æ–≤–∫–æ–π
    data[key] = result
}

// ‚úÖ –ú–∏–Ω–∏–º–∏–∑–∏—Ä—É–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫—É—é —Å–µ–∫—Ü–∏—é
func process() {
    result := heavyComputation()  // –í–Ω–µ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏
    
    mu.Lock()
    data[key] = result  // –¢–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø –∫ –¥–∞–Ω–Ω—ã–º
    mu.Unlock()
}
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞—á–∞ 1: –°—á—ë—Ç—á–∏–∫
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å—á—ë—Ç—á–∏–∫ —Å Inc, Dec, Value.

### –ó–∞–¥–∞—á–∞ 2: Stack
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å—Ç–µ–∫ —Å Push, Pop.

### –ó–∞–¥–∞—á–∞ 3: LRU Cache
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π LRU –∫—ç—à.

### –ó–∞–¥–∞—á–∞ 4: Rate limiter
–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º—å—é—Ç–µ–∫—Å –¥–ª—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ token bucket rate limiter.

### –ó–∞–¥–∞—á–∞ 5: Read-heavy cache
–û–ø—Ç–∏–º–∏–∑–∏—Ä—É–π—Ç–µ –∫—ç—à —Å —á–∞—Å—Ç—ã–º —á—Ç–µ–Ω–∏–µ–º –∏—Å–ø–æ–ª—å–∑—É—è RWMutex.

### –ó–∞–¥–∞—á–∞ 6: Lazy init
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –ª–µ–Ω–∏–≤—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é —Å –º—å—é—Ç–µ–∫—Å–æ–º (—Å—Ä–∞–≤–Ω–∏—Ç–µ —Å sync.Once).

### –ó–∞–¥–∞—á–∞ 7: Connection pool
–°–æ–∑–¥–∞–π—Ç–µ –ø—É–ª —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π —Å –ª–∏–º–∏—Ç–æ–º.

### –ó–∞–¥–∞—á–∞ 8: Semaphore
–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Å–µ–º–∞—Ñ–æ—Ä –Ω–∞ –æ—Å–Ω–æ–≤–µ –º—å—é—Ç–µ–∫—Å–∞ –∏ —É—Å–ª–æ–≤–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.
