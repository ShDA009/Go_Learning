# –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏

---

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

- **–†–µ–∫—É—Ä—Å–∏—è** ‚Äî —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–∑—ã–≤–∞–µ—Ç —Å–∞–º—É —Å–µ–±—è
- –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω—É–∂–µ–Ω **–±–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π** –¥–ª—è –ø—Ä–µ–∫—Ä–∞—â–µ–Ω–∏—è —Ä–µ–∫—É—Ä—Å–∏–∏
- –ö–∞–∂–¥—ã–π —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤ –¥–æ–ª–∂–µ–Ω **–ø—Ä–∏–±–ª–∏–∂–∞—Ç—å—Å—è –∫ –±–∞–∑–æ–≤–æ–º—É —Å–ª—É—á–∞—é**
- –†–µ–∫—É—Ä—Å–∏—è —É–¥–æ–±–Ω–∞ –¥–ª—è: –¥–µ—Ä–µ–≤—å–µ–≤, –≥—Ä–∞—Ñ–æ–≤, –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä
- –ì–ª—É–±–æ–∫–∞—è —Ä–µ–∫—É—Ä—Å–∏—è –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å **–ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ —Å—Ç–µ–∫–∞**

### –°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏

```go
func recursive(–ø–∞—Ä–∞–º–µ—Ç—Ä—ã) —Ä–µ–∑—É–ª—å—Ç–∞—Ç {
    // 1. –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π (—É—Å–ª–æ–≤–∏–µ –≤—ã—Ö–æ–¥–∞)
    if —É—Å–ª–æ–≤–∏–µ_–≤—ã—Ö–æ–¥–∞ {
        return –±–∞–∑–æ–≤–æ–µ_–∑–Ω–∞—á–µ–Ω–∏–µ
    }
    
    // 2. –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π —Å–ª—É—á–∞–π
    return —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π_–≤—ã–∑–æ–≤(–∏–∑–º–µ–Ω—ë–Ω–Ω—ã–µ_–ø–∞—Ä–∞–º–µ—Ç—Ä—ã)
}
```

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–µ–∫—É—Ä—Å–∏—é?

| –•–æ—Ä–æ—à–æ –¥–ª—è | –ü–ª–æ—Ö–æ –¥–ª—è |
|------------|-----------|
| –î–µ—Ä–µ–≤—å—è, –≥—Ä–∞—Ñ—ã | –ü—Ä–æ—Å—Ç—ã–µ —Ü–∏–∫–ª—ã |
| –í–ª–æ–∂–µ–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã | –ë–æ–ª—å—à–∏–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ |
| –†–∞–∑–¥–µ–ª—è–π –∏ –≤–ª–∞—Å—Ç–≤—É–π | –õ–∏–Ω–µ–π–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ |
| –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ñ–æ—Ä–º—É–ª—ã | –ö–æ–≥–¥–∞ –≤–∞–∂–Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å |

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### –ë–∞–∑–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞
```go
func factorial(n int) int {
    if n <= 1 {           // –±–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π
        return 1
    }
    return n * factorial(n-1)  // —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤
}
```

### –†–µ–∫—É—Ä—Å–∏—è —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –±–∞–∑–æ–≤—ã–º–∏ —Å–ª—É—á–∞—è–º–∏
```go
func fibonacci(n int) int {
    if n == 0 { return 0 }  // –±–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π 1
    if n == 1 { return 1 }  // –±–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π 2
    return fibonacci(n-1) + fibonacci(n-2)
}
```

### –•–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è
```go
func factorialTail(n, acc int) int {
    if n <= 1 {
        return acc
    }
    return factorialTail(n-1, n*acc)  // –ø–æ—Å–ª–µ–¥–Ω—è—è –æ–ø–µ—Ä–∞—Ü–∏—è ‚Äî –≤—ã–∑–æ–≤
}
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ü—Ä–∏–º–µ—Ä 1: –§–∞–∫—Ç–æ—Ä–∏–∞–ª
```go
package main

import "fmt"

func factorial(n uint) uint {
    if n == 0 {
        return 1
    }
    return n * factorial(n-1)
}

func main() {
    fmt.Println("0! =", factorial(0))  // 1
    fmt.Println("1! =", factorial(1))  // 1
    fmt.Println("5! =", factorial(5))  // 120
    fmt.Println("10! =", factorial(10)) // 3628800
    
    // –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è:
    // factorial(4)
    // = 4 * factorial(3)
    // = 4 * 3 * factorial(2)
    // = 4 * 3 * 2 * factorial(1)
    // = 4 * 3 * 2 * 1 * factorial(0)
    // = 4 * 3 * 2 * 1 * 1
    // = 24
}
```

### –ü—Ä–∏–º–µ—Ä 2: –ß–∏—Å–ª–∞ –§–∏–±–æ–Ω–∞—á—á–∏
```go
package main

import "fmt"

func fibonacci(n int) int {
    if n <= 0 {
        return 0
    }
    if n == 1 {
        return 1
    }
    return fibonacci(n-1) + fibonacci(n-2)
}

func main() {
    fmt.Print("–§–∏–±–æ–Ω–∞—á—á–∏: ")
    for i := 0; i < 12; i++ {
        fmt.Print(fibonacci(i), " ")
    }
    fmt.Println()
    // 0 1 1 2 3 5 8 13 21 34 55 89
}
```

### –ü—Ä–∏–º–µ—Ä 3: –°—É–º–º–∞ —á–∏—Å–µ–ª
```go
package main

import "fmt"

func sum(n int) int {
    if n <= 0 {
        return 0
    }
    return n + sum(n-1)
}

func sumSlice(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    return nums[0] + sumSlice(nums[1:])
}

func main() {
    fmt.Println("sum(10) =", sum(10))  // 55
    
    numbers := []int{1, 2, 3, 4, 5}
    fmt.Println("sumSlice =", sumSlice(numbers))  // 15
}
```

### –ü—Ä–∏–º–µ—Ä 4: –°—Ç–µ–ø–µ–Ω—å —á–∏—Å–ª–∞
```go
package main

import "fmt"

func power(base, exp int) int {
    if exp == 0 {
        return 1
    }
    if exp < 0 {
        return 0  // –¥–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ
    }
    return base * power(base, exp-1)
}

// –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è (–±—ã—Å—Ç—Ä–æ–µ –≤–æ–∑–≤–µ–¥–µ–Ω–∏–µ –≤ —Å—Ç–µ–ø–µ–Ω—å)
func powerFast(base, exp int) int {
    if exp == 0 {
        return 1
    }
    if exp%2 == 0 {
        half := powerFast(base, exp/2)
        return half * half
    }
    return base * powerFast(base, exp-1)
}

func main() {
    fmt.Println("2^10 =", power(2, 10))      // 1024
    fmt.Println("2^10 =", powerFast(2, 10))  // 1024
    fmt.Println("3^5 =", power(3, 5))        // 243
}
```

### –ü—Ä–∏–º–µ—Ä 5: –û–±—Ö–æ–¥ –¥–µ—Ä–µ–≤–∞
```go
package main

import "fmt"

type Node struct {
    Value int
    Left  *Node
    Right *Node
}

// –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ –≤ –≥–ª—É–±–∏–Ω—É
func inOrder(node *Node) {
    if node == nil {
        return
    }
    inOrder(node.Left)
    fmt.Print(node.Value, " ")
    inOrder(node.Right)
}

func sumTree(node *Node) int {
    if node == nil {
        return 0
    }
    return node.Value + sumTree(node.Left) + sumTree(node.Right)
}

func maxDepth(node *Node) int {
    if node == nil {
        return 0
    }
    leftDepth := maxDepth(node.Left)
    rightDepth := maxDepth(node.Right)
    
    if leftDepth > rightDepth {
        return leftDepth + 1
    }
    return rightDepth + 1
}

func main() {
    //       4
    //      / \
    //     2   6
    //    / \ / \
    //   1  3 5  7
    
    root := &Node{Value: 4,
        Left: &Node{Value: 2,
            Left:  &Node{Value: 1},
            Right: &Node{Value: 3},
        },
        Right: &Node{Value: 6,
            Left:  &Node{Value: 5},
            Right: &Node{Value: 7},
        },
    }
    
    fmt.Print("In-order: ")
    inOrder(root)  // 1 2 3 4 5 6 7
    fmt.Println()
    
    fmt.Println("–°—É–º–º–∞ —É–∑–ª–æ–≤:", sumTree(root))  // 28
    fmt.Println("–ì–ª—É–±–∏–Ω–∞:", maxDepth(root))     // 3
}
```

### –ü—Ä–∏–º–µ—Ä 6: –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –æ–±—Ö–æ–¥ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π
```go
package main

import (
    "fmt"
    "os"
    "path/filepath"
)

func listFiles(path string, indent int) {
    entries, err := os.ReadDir(path)
    if err != nil {
        return
    }
    
    for _, entry := range entries {
        // –û—Ç—Å—Ç—É–ø –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        for i := 0; i < indent; i++ {
            fmt.Print("  ")
        }
        
        if entry.IsDir() {
            fmt.Println("üìÅ", entry.Name())
            // –†–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –≤—ã–∑–æ–≤ –¥–ª—è –ø–æ–¥–¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            listFiles(filepath.Join(path, entry.Name()), indent+1)
        } else {
            fmt.Println("üìÑ", entry.Name())
        }
    }
}

func main() {
    fmt.Println("–°—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ç–µ–∫—É—â–µ–π –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏:")
    listFiles(".", 0)
}
```

### –ü—Ä–∏–º–µ—Ä 7: –ü–∞–ª–∏–Ω–¥—Ä–æ–º
```go
package main

import (
    "fmt"
    "strings"
)

func isPalindrome(s string) bool {
    s = strings.ToLower(s)
    
    if len(s) <= 1 {
        return true
    }
    
    if s[0] != s[len(s)-1] {
        return false
    }
    
    return isPalindrome(s[1 : len(s)-1])
}

func main() {
    words := []string{"radar", "level", "hello", "–ê —Ä–æ–∑–∞ —É–ø–∞–ª–∞ –Ω–∞ –ª–∞–ø—É –ê–∑–æ—Ä–∞"}
    
    for _, word := range words {
        // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ—Ä–∞–∑
        clean := strings.ReplaceAll(word, " ", "")
        result := isPalindrome(clean)
        fmt.Printf("%q ‚Äî –ø–∞–ª–∏–Ω–¥—Ä–æ–º: %t\n", word, result)
    }
}
```

### –ü—Ä–∏–º–µ—Ä 8: –•–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è (–æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è)
```go
package main

import "fmt"

// –û–±—ã—á–Ω–∞—è —Ä–µ–∫—É—Ä—Å–∏—è ‚Äî –Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ—Ç —Å—Ç–µ–∫
func factorialNormal(n int) int {
    if n <= 1 {
        return 1
    }
    return n * factorialNormal(n-1)
}

// –•–≤–æ—Å—Ç–æ–≤–∞—è —Ä–µ–∫—É—Ä—Å–∏—è ‚Äî –∞–∫–∫—É–º—É–ª—è—Ç–æ—Ä –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º
func factorialTail(n, acc int) int {
    if n <= 1 {
        return acc
    }
    return factorialTail(n-1, n*acc)  // –ø–æ—Å–ª–µ–¥–Ω—è—è –æ–ø–µ—Ä–∞—Ü–∏—è ‚Äî –≤—ã–∑–æ–≤
}

func factorial(n int) int {
    return factorialTail(n, 1)
}

// –°—Ä–∞–≤–Ω–µ–Ω–∏–µ: –§–∏–±–æ–Ω–∞—á—á–∏
func fibSlow(n int) int {
    if n <= 1 {
        return n
    }
    return fibSlow(n-1) + fibSlow(n-2)  // —ç–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å!
}

func fibTail(n, a, b int) int {
    if n == 0 {
        return a
    }
    return fibTail(n-1, b, a+b)  // –ª–∏–Ω–µ–π–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å
}

func fibFast(n int) int {
    return fibTail(n, 0, 1)
}

func main() {
    fmt.Println("factorial(10) =", factorial(10))
    
    fmt.Println("fibSlow(10) =", fibSlow(10))
    fmt.Println("fibFast(10) =", fibFast(10))
    fmt.Println("fibFast(40) =", fibFast(40))  // –±—ã—Å—Ç—Ä–æ!
    // fibSlow(40) –±—ã–ª –±—ã –æ—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω—ã–º
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –±–∞–∑–æ–≤–æ–≥–æ —Å–ª—É—á–∞—è
```go
// ‚ùå –ë–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è —Ä–µ–∫—É—Ä—Å–∏—è ‚Äî stack overflow!
func infinite(n int) int {
    return infinite(n - 1)  // –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è
}

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ ‚Äî –µ—Å—Ç—å –±–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π
func finite(n int) int {
    if n <= 0 {
        return 0
    }
    return finite(n - 1)
}
```

### 2. –ë–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º
```go
// ‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ ‚Äî –±–∞–∑–æ–≤—ã–π —Å–ª—É—á–∞–π –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç
func wrong(n int) int {
    if n == 0 {
        return 0
    }
    return wrong(n + 1)  // —É–¥–∞–ª—è–µ—Ç—Å—è –æ—Ç –±–∞–∑–æ–≤–æ–≥–æ —Å–ª—É—á–∞—è!
}

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ ‚Äî –ø—Ä–∏–±–ª–∏–∂–∞–µ–º—Å—è –∫ –±–∞–∑–æ–≤–æ–º—É —Å–ª—É—á–∞—é
func correct(n int) int {
    if n <= 0 {
        return 0
    }
    return correct(n - 1)  // –ø—Ä–∏–±–ª–∏–∂–∞–µ–º—Å—è –∫ 0
}
```

### 3. –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è —Å–ª–æ–∂–Ω–æ—Å—Ç—å –§–∏–±–æ–Ω–∞—á—á–∏
```go
// ‚ùå –û—á–µ–Ω—å –º–µ–¥–ª–µ–Ω–Ω–æ –¥–ª—è –±–æ–ª—å—à–∏—Ö n
func fibSlow(n int) int {
    if n <= 1 { return n }
    return fibSlow(n-1) + fibSlow(n-2)  // O(2^n)!
}

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ–º–æ–∏–∑–∞—Ü–∏—é –∏–ª–∏ –∏—Ç–µ—Ä–∞—Ü–∏—é
func fibMemo(n int, cache map[int]int) int {
    if n <= 1 { return n }
    if val, ok := cache[n]; ok {
        return val
    }
    cache[n] = fibMemo(n-1, cache) + fibMemo(n-2, cache)
    return cache[n]
}
```

### 4. –ü–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ —Å—Ç–µ–∫–∞
```go
// ‚ùå –°–ª–∏—à–∫–æ–º –≥–ª—É–±–æ–∫–∞—è —Ä–µ–∫—É—Ä—Å–∏—è
func deep(n int) int {
    if n == 0 { return 0 }
    return 1 + deep(n - 1)
}

func main() {
    deep(1000000)  // runtime: goroutine stack exceeds
}

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∏—Ç–µ—Ä–∞—Ü–∏—é –¥–ª—è –±–æ–ª—å—à–∏—Ö n
func deepIter(n int) int {
    result := 0
    for i := 0; i < n; i++ {
        result++
    }
    return result
}
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞–Ω–∏–µ 1: –°—É–º–º–∞ —Ü–∏—Ñ—Ä
–ù–∞–ø–∏—à–∏—Ç–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è —Å—É–º–º—ã —Ü–∏—Ñ—Ä —á–∏—Å–ª–∞.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func sumDigits(n int) int {
    if n < 0 {
        n = -n
    }
    if n < 10 {
        return n
    }
    return n%10 + sumDigits(n/10)
}

func main() {
    fmt.Println("sumDigits(12345) =", sumDigits(12345))  // 15
    fmt.Println("sumDigits(999) =", sumDigits(999))      // 27
}
```
</details>

### –ó–∞–¥–∞–Ω–∏–µ 2: –†–µ–≤–µ—Ä—Å —Å—Ç—Ä–æ–∫–∏
–ù–∞–ø–∏—à–∏—Ç–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–µ—Ä–µ–≤–æ—Ä–æ—Ç–∞ —Å—Ç—Ä–æ–∫–∏.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func reverse(s string) string {
    if len(s) <= 1 {
        return s
    }
    return reverse(s[1:]) + string(s[0])
}

func main() {
    fmt.Println(reverse("hello"))  // olleh
    fmt.Println(reverse("Go"))     // oG
}
```
</details>

### –ó–∞–¥–∞–Ω–∏–µ 3: –ù–∞–∏–±–æ–ª—å—à–∏–π –æ–±—â–∏–π –¥–µ–ª–∏—Ç–µ–ª—å (–ù–û–î)
–†–µ–∞–ª–∏–∑—É–π—Ç–µ –∞–ª–≥–æ—Ä–∏—Ç–º –ï–≤–∫–ª–∏–¥–∞ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func gcd(a, b int) int {
    if b == 0 {
        return a
    }
    return gcd(b, a%b)
}

func main() {
    fmt.Println("gcd(48, 18) =", gcd(48, 18))  // 6
    fmt.Println("gcd(100, 25) =", gcd(100, 25)) // 25
}
```
</details>

### –ó–∞–¥–∞–Ω–∏–µ 4: –ë–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫
–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–µ–∫—É—Ä—Å–∏–≤–Ω—ã–π –±–∏–Ω–∞—Ä–Ω—ã–π –ø–æ–∏—Å–∫.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func binarySearch(arr []int, target, low, high int) int {
    if low > high {
        return -1
    }
    
    mid := (low + high) / 2
    
    if arr[mid] == target {
        return mid
    }
    if arr[mid] > target {
        return binarySearch(arr, target, low, mid-1)
    }
    return binarySearch(arr, target, mid+1, high)
}

func main() {
    arr := []int{1, 3, 5, 7, 9, 11, 13, 15}
    
    idx := binarySearch(arr, 7, 0, len(arr)-1)
    fmt.Println("–ò–Ω–¥–µ–∫—Å 7:", idx)  // 3
    
    idx = binarySearch(arr, 6, 0, len(arr)-1)
    fmt.Println("–ò–Ω–¥–µ–∫—Å 6:", idx)  // -1
}
```
</details>

### –ó–∞–¥–∞–Ω–∏–µ 5: –•–∞–Ω–æ–π—Å–∫–∏–µ –±–∞—à–Ω–∏
–†–µ—à–∏—Ç–µ –∑–∞–¥–∞—á—É –æ –•–∞–Ω–æ–π—Å–∫–∏—Ö –±–∞—à–Ω—è—Ö.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func hanoi(n int, from, to, aux string) {
    if n == 1 {
        fmt.Printf("–î–∏—Å–∫ 1: %s -> %s\n", from, to)
        return
    }
    
    hanoi(n-1, from, aux, to)
    fmt.Printf("–î–∏—Å–∫ %d: %s -> %s\n", n, from, to)
    hanoi(n-1, aux, to, from)
}

func main() {
    fmt.Println("–†–µ—à–µ–Ω–∏–µ –¥–ª—è 3 –¥–∏—Å–∫–æ–≤:")
    hanoi(3, "A", "C", "B")
}
```
</details>

---

## üîó –ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏

- [Go by Example ‚Äî Recursion](https://gobyexample.com/recursion)
- [Recursion in Go](https://yourbasic.org/golang/recursion/)
