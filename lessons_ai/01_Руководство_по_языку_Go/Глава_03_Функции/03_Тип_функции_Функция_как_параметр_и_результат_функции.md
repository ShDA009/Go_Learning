# –¢–∏–ø —Ñ—É–Ω–∫—Ü–∏–∏. –§—É–Ω–∫—Ü–∏—è –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç

---

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

- –ö–∞–∂–¥–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∏–º–µ–µ—Ç **—Ç–∏–ø**, –æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –∏ –≤–æ–∑–≤—Ä–∞—Ç–æ–º
- –§—É–Ω–∫—Ü–∏–∏ ‚Äî —ç—Ç–æ **–∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞** (first-class citizens)
- –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –º–æ–∂–µ—Ç **—Ö—Ä–∞–Ω–∏—Ç—å —Ñ—É–Ω–∫—Ü–∏—é** —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —Ç–∏–ø–∞
- –§—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç **–ø—Ä–∏–Ω–∏–º–∞—Ç—å –¥—Ä—É–≥—É—é —Ñ—É–Ω–∫—Ü–∏—é** –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä
- –§—É–Ω–∫—Ü–∏—è –º–æ–∂–µ—Ç **–≤–æ–∑–≤—Ä–∞—â–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é** –∫–∞–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
- –≠—Ç–æ –æ—Å–Ω–æ–≤–∞ –¥–ª—è **—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è** –≤ Go

### –ü—Ä–∏–º–µ—Ä—ã —Ç–∏–ø–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π

| –§—É–Ω–∫—Ü–∏—è | –¢–∏–ø |
|---------|-----|
| `func add(a, b int) int` | `func(int, int) int` |
| `func print(s string)` | `func(string)` |
| `func now() time.Time` | `func() time.Time` |
| `func convert(f func(int) int, x int) int` | `func(func(int) int, int) int` |

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### –û–±—ä—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π-—Ñ—É–Ω–∫—Ü–∏–∏
```go
var f func(int, int) int
f = add  // –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏
```

### –§—É–Ω–∫—Ü–∏—è –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä
```go
func process(data int, fn func(int) int) int {
    return fn(data)
}
```

### –§—É–Ω–∫—Ü–∏—è –∫–∞–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
```go
func getOperation(op string) func(int, int) int {
    // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ—É–Ω–∫—Ü–∏—é
}
```

### –ü—Å–µ–≤–¥–æ–Ω–∏–º —Ç–∏–ø–∞ —Ñ—É–Ω–∫—Ü–∏–∏
```go
type Operation func(int, int) int

func calculate(a, b int, op Operation) int {
    return op(a, b)
}
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ü—Ä–∏–º–µ—Ä 1: –§—É–Ω–∫—Ü–∏—è –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ
```go
package main

import "fmt"

func add(a, b int) int { return a + b }
func sub(a, b int) int { return a - b }
func mul(a, b int) int { return a * b }

func main() {
    // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–∏–ø–∞ —Ñ—É–Ω–∫—Ü–∏–∏
    var operation func(int, int) int
    
    operation = add
    fmt.Println("add(5, 3) =", operation(5, 3))  // 8
    
    operation = sub
    fmt.Println("sub(5, 3) =", operation(5, 3))  // 2
    
    operation = mul
    fmt.Println("mul(5, 3) =", operation(5, 3))  // 15
}
```

### –ü—Ä–∏–º–µ—Ä 2: –¢–∏–ø-–ø—Å–µ–≤–¥–æ–Ω–∏–º –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏
```go
package main

import "fmt"

// –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –¥–ª—è –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
type MathOp func(int, int) int

func add(a, b int) int { return a + b }
func sub(a, b int) int { return a - b }

func main() {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ç–∏–ø MathOp
    operations := map[string]MathOp{
        "+": add,
        "-": sub,
    }
    
    fmt.Println("10 + 5 =", operations["+"](10, 5))
    fmt.Println("10 - 5 =", operations["-"](10, 5))
}
```

### –ü—Ä–∏–º–µ—Ä 3: –§—É–Ω–∫—Ü–∏—è –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä (callback)
```go
package main

import "fmt"

// apply –ø—Ä–∏–º–µ–Ω—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é fn –∫ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É —Å—Ä–µ–∑–∞
func apply(numbers []int, fn func(int) int) []int {
    result := make([]int, len(numbers))
    for i, n := range numbers {
        result[i] = fn(n)
    }
    return result
}

func double(x int) int { return x * 2 }
func square(x int) int { return x * x }

func main() {
    nums := []int{1, 2, 3, 4, 5}
    
    doubled := apply(nums, double)
    fmt.Println("–£–¥–≤–æ–µ–Ω–Ω—ã–µ:", doubled)  // [2 4 6 8 10]
    
    squared := apply(nums, square)
    fmt.Println("–ö–≤–∞–¥—Ä–∞—Ç—ã:", squared)   // [1 4 9 16 25]
}
```

### –ü—Ä–∏–º–µ—Ä 4: –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è —Å –ø—Ä–µ–¥–∏–∫–∞—Ç–æ–º
```go
package main

import "fmt"

// filter –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–ª–µ–º–µ–Ω—Ç—ã, –¥–ª—è –∫–æ—Ç–æ—Ä—ã—Ö predicate –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç true
func filter(numbers []int, predicate func(int) bool) []int {
    result := []int{}
    for _, n := range numbers {
        if predicate(n) {
            result = append(result, n)
        }
    }
    return result
}

func isEven(n int) bool     { return n%2 == 0 }
func isPositive(n int) bool { return n > 0 }

func main() {
    nums := []int{-3, -1, 0, 1, 2, 3, 4, 5}
    
    evens := filter(nums, isEven)
    fmt.Println("–ß—ë—Ç–Ω—ã–µ:", evens)  // [0 2 4]
    
    positives := filter(nums, isPositive)
    fmt.Println("–ü–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–µ:", positives)  // [1 2 3 4 5]
}
```

### –ü—Ä–∏–º–µ—Ä 5: –§—É–Ω–∫—Ü–∏—è –∫–∞–∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç (—Ñ–∞–±—Ä–∏–∫–∞)
```go
package main

import "fmt"

// getMultiplier –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é —É–º–Ω–æ–∂–µ–Ω–∏—è –Ω–∞ n
func getMultiplier(n int) func(int) int {
    return func(x int) int {
        return x * n
    }
}

// getComparator –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å –ø–æ—Ä–æ–≥–æ–º
func getComparator(threshold int) func(int) bool {
    return func(x int) bool {
        return x > threshold
    }
}

func main() {
    // –°–æ–∑–¥–∞—ë–º —Ñ—É–Ω–∫—Ü–∏–∏-—É–º–Ω–æ–∂–∏—Ç–µ–ª–∏
    double := getMultiplier(2)
    triple := getMultiplier(3)
    
    fmt.Println("5 * 2 =", double(5))  // 10
    fmt.Println("5 * 3 =", triple(5))  // 15
    
    // –°–æ–∑–¥–∞—ë–º –∫–æ–º–ø–∞—Ä–∞—Ç–æ—Ä—ã
    greaterThan10 := getComparator(10)
    greaterThan100 := getComparator(100)
    
    fmt.Println("15 > 10:", greaterThan10(15))    // true
    fmt.Println("15 > 100:", greaterThan100(15))  // false
}
```

### –ü—Ä–∏–º–µ—Ä 6: –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä —Å —Ñ—É–Ω–∫—Ü–∏—è–º–∏
```go
package main

import (
    "errors"
    "fmt"
)

type Operation func(float64, float64) (float64, error)

func add(a, b float64) (float64, error) { return a + b, nil }
func sub(a, b float64) (float64, error) { return a - b, nil }
func mul(a, b float64) (float64, error) { return a * b, nil }
func div(a, b float64) (float64, error) {
    if b == 0 {
        return 0, errors.New("–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –Ω–æ–ª—å")
    }
    return a / b, nil
}

func getOperation(op string) (Operation, error) {
    operations := map[string]Operation{
        "+": add,
        "-": sub,
        "*": mul,
        "/": div,
    }
    
    fn, ok := operations[op]
    if !ok {
        return nil, errors.New("–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è")
    }
    return fn, nil
}

func calculate(a float64, op string, b float64) (float64, error) {
    fn, err := getOperation(op)
    if err != nil {
        return 0, err
    }
    return fn(a, b)
}

func main() {
    ops := []string{"+", "-", "*", "/"}
    a, b := 10.0, 3.0
    
    for _, op := range ops {
        result, err := calculate(a, op, b)
        if err != nil {
            fmt.Printf("%.0f %s %.0f = –û—à–∏–±–∫–∞: %v\n", a, op, b, err)
        } else {
            fmt.Printf("%.0f %s %.0f = %.2f\n", a, op, b, result)
        }
    }
}
```

### –ü—Ä–∏–º–µ—Ä 7: Middleware pattern
```go
package main

import "fmt"

type Handler func(string) string

// withLogging –æ–±–æ—Ä–∞—á–∏–≤–∞–µ—Ç –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
func withLogging(h Handler) Handler {
    return func(input string) string {
        fmt.Printf("–í—Ö–æ–¥: %q\n", input)
        result := h(input)
        fmt.Printf("–í—ã—Ö–æ–¥: %q\n", result)
        return result
    }
}

// withPrefix –¥–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
func withPrefix(prefix string, h Handler) Handler {
    return func(input string) string {
        return prefix + h(input)
    }
}

func uppercase(s string) string {
    result := ""
    for _, c := range s {
        if c >= 'a' && c <= 'z' {
            result += string(c - 32)
        } else {
            result += string(c)
        }
    }
    return result
}

func main() {
    // –ë–∞–∑–æ–≤—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫
    handler := uppercase
    fmt.Println(handler("hello"))  // HELLO
    
    // –° –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º
    logged := withLogging(uppercase)
    logged("world")
    
    // –° –ø—Ä–µ—Ñ–∏–∫—Å–æ–º
    prefixed := withPrefix("Result: ", uppercase)
    fmt.Println(prefixed("test"))  // Result: TEST
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ù–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ —Ç–∏–ø–∞ —Ñ—É–Ω–∫—Ü–∏–∏
```go
// ‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ ‚Äî —Ç–∏–ø—ã –Ω–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç
func add(a, b int) int { return a + b }
var f func(int) int = add  // cannot use add as func(int) int

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ
var f func(int, int) int = add
```

### 2. –í—ã–∑–æ–≤ nil-—Ñ—É–Ω–∫—Ü–∏–∏
```go
// ‚ùå –ü–∞–Ω–∏–∫–∞ –ø—Ä–∏ –≤—ã–∑–æ–≤–µ nil
var f func(int) int  // f == nil
f(5)  // panic: invalid memory address

// ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–π—Ç–µ –Ω–∞ nil
if f != nil {
    f(5)
}
```

### 3. –ü—É—Ç–∞–Ω–∏—Ü–∞ —Å—Å—ã–ª–∫–∏ –∏ –≤—ã–∑–æ–≤–∞
```go
func greet() { fmt.Println("Hello") }

// ‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ ‚Äî –ø–µ—Ä–µ–¥–∞—ë–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç, –∞ –Ω–µ —Ñ—É–Ω–∫—Ü–∏—é
var f = greet()  // f = nil (greet –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –Ω–∏—á–µ–≥–æ)

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ ‚Äî –ø–µ—Ä–µ–¥–∞—ë–º —Ñ—É–Ω–∫—Ü–∏—é
var f = greet    // f = func()
f()              // –≤—ã–∑—ã–≤–∞–µ–º
```

### 4. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—Ç–∞
```go
// ‚ùå –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ
func factory() func(int) {
    return func(x int) int { return x * 2 }  // –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞
}

// ‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–æ
func factory() func(int) int {
    return func(x int) int { return x * 2 }
}
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞–Ω–∏–µ 1: –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è —Å—Ä–µ–∑–∞
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `transform`, –ø—Ä–∏–º–µ–Ω—è—é—â—É—é —Ñ—É–Ω–∫—Ü–∏—é –∫ –∫–∞–∂–¥–æ–º—É —ç–ª–µ–º–µ–Ω—Ç—É —Å—Ä–µ–∑–∞ —Å—Ç—Ä–æ–∫.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import (
    "fmt"
    "strings"
)

func transform(items []string, fn func(string) string) []string {
    result := make([]string, len(items))
    for i, item := range items {
        result[i] = fn(item)
    }
    return result
}

func main() {
    words := []string{"hello", "world", "go"}
    
    upper := transform(words, strings.ToUpper)
    fmt.Println("Upper:", upper)  // [HELLO WORLD GO]
    
    titled := transform(words, strings.Title)
    fmt.Println("Title:", titled)  // [Hello World Go]
}
```
</details>

### –ó–∞–¥–∞–Ω–∏–µ 2: –ö–æ–º–ø–æ–∑–∏—Ü–∏—è —Ñ—É–Ω–∫—Ü–∏–π
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `compose`, –æ–±—ä–µ–¥–∏–Ω—è—é—â—É—é –¥–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func compose(f, g func(int) int) func(int) int {
    return func(x int) int {
        return f(g(x))
    }
}

func double(x int) int { return x * 2 }
func addOne(x int) int { return x + 1 }

func main() {
    // (x + 1) * 2
    f := compose(double, addOne)
    fmt.Println("f(5) =", f(5))  // 12
    
    // (x * 2) + 1
    g := compose(addOne, double)
    fmt.Println("g(5) =", g(5))  // 11
}
```
</details>

### –ó–∞–¥–∞–Ω–∏–µ 3: –ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å—Ç–µ–ø–µ–Ω–µ–π
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Å—Ç–µ–ø–µ–Ω–µ–π —á–∏—Å–ª–∞.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func powerGenerator(base int) func() int {
    power := 1
    return func() int {
        result := power
        power *= base
        return result
    }
}

func main() {
    powersOf2 := powerGenerator(2)
    for i := 0; i < 8; i++ {
        fmt.Print(powersOf2(), " ")  // 1 2 4 8 16 32 64 128
    }
    fmt.Println()
    
    powersOf3 := powerGenerator(3)
    for i := 0; i < 5; i++ {
        fmt.Print(powersOf3(), " ")  // 1 3 9 27 81
    }
}
```
</details>

### –ó–∞–¥–∞–Ω–∏–µ 4: Reduce (—Å–≤—ë—Ä—Ç–∫–∞)
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `reduce` –¥–ª—è —Å–≤—ë—Ä—Ç–∫–∏ —Å—Ä–µ–∑–∞.

<details>
<summary>–†–µ—à–µ–Ω–∏–µ</summary>

```go
package main

import "fmt"

func reduce(numbers []int, fn func(int, int) int, initial int) int {
    result := initial
    for _, n := range numbers {
        result = fn(result, n)
    }
    return result
}

func main() {
    nums := []int{1, 2, 3, 4, 5}
    
    sum := reduce(nums, func(a, b int) int { return a + b }, 0)
    fmt.Println("–°—É–º–º–∞:", sum)  // 15
    
    product := reduce(nums, func(a, b int) int { return a * b }, 1)
    fmt.Println("–ü—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ:", product)  // 120
    
    max := reduce(nums, func(a, b int) int {
        if b > a { return b }
        return a
    }, nums[0])
    fmt.Println("–ú–∞–∫—Å–∏–º—É–º:", max)  // 5
}
```
</details>

---

## üîó –ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏

- [A Tour of Go ‚Äî Function values](https://go.dev/tour/moretypes/24)
- [Go by Example ‚Äî Closures](https://gobyexample.com/closures)
