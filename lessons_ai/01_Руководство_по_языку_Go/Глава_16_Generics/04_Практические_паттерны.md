# –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã —Å Generics

---

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **–§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã** ‚Äî Map, Filter, Reduce –¥–ª—è —Å—Ä–µ–∑–æ–≤
2. **Builder pattern** ‚Äî —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
3. **Repository pattern** ‚Äî –æ–±–æ–±—â—ë–Ω–Ω—ã–µ —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏
4. **Type-safe events** ‚Äî —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è
5. **Sync-–ø—Ä–∏–º–∏—Ç–∏–≤—ã** ‚Äî –æ–±–æ–±—â—ë–Ω–Ω—ã–µ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

---

## üìñ –¢–µ–æ—Ä–∏—è

### –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã: Map, Filter, Reduce

–≠—Ç–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∏—à–ª–∏ –∏–∑ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –æ—á–µ–Ω—å –ø–æ–ø—É–ª—è—Ä–Ω—ã –≤ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö (JavaScript, Python, Java Streams). –î–æ Generics –≤ Go –∏—Ö –±—ã–ª–æ —Å–ª–æ–∂–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ.

**Map** ‚Äî –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞:
```
[1, 2, 3] ‚Üí map(x => x * 2) ‚Üí [2, 4, 6]
```

**Filter** ‚Äî –≤—ã–±–æ—Ä —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —É—Å–ª–æ–≤–∏—é:
```
[1, 2, 3, 4, 5] ‚Üí filter(x => x > 2) ‚Üí [3, 4, 5]
```

**Reduce** ‚Äî —Å–≤—ë—Ä—Ç–∫–∞ –≤ –æ–¥–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ:
```
[1, 2, 3, 4] ‚Üí reduce(sum) ‚Üí 10
```

–¢–µ–ø–µ—Ä—å —Å Generics —ç—Ç–æ –ª–µ–≥–∫–æ:
```go
func Map[T, R any](slice []T, fn func(T) R) []R { ... }
func Filter[T any](slice []T, predicate func(T) bool) []T { ... }
func Reduce[T, R any](slice []T, initial R, fn func(R, T) R) R { ... }
```

### Result Type ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫

–í–º–µ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—Ç–∞ `(value, error)` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∏–ø Result:

```go
type Result[T any] struct {
    value T
    err   error
}

func (r Result[T]) IsOk() bool {
    return r.err == nil
}

func (r Result[T]) Unwrap() T {
    if r.err != nil {
        panic(r.err)
    }
    return r.value
}
```

–≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–∏—Å–∞—Ç—å —Ü–µ–ø–æ—á–∫–∏ –≤—ã–∑–æ–≤–æ–≤:
```go
result := FetchUser(1).
    Map(func(u User) Profile { return u.Profile }).
    Filter(func(p Profile) bool { return p.Active })
```

### Optional Type ‚Äî –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è

–ö–æ–≥–¥–∞ –∑–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å:

```go
type Optional[T any] struct {
    value   T
    present bool
}

func Some[T any](value T) Optional[T] {
    return Optional[T]{value: value, present: true}
}

func None[T any]() Optional[T] {
    return Optional[T]{present: false}
}
```

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
```go
func FindUser(id int) Optional[User] {
    user, found := db.Get(id)
    if !found {
        return None[User]()
    }
    return Some(user)
}
```

### Generic Repository Pattern

–¢–∏–ø–∏—á–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö:

```go
type Repository[T any, ID comparable] interface {
    FindByID(id ID) (T, error)
    FindAll() ([]T, error)
    Save(entity T) error
    Delete(id ID) error
}
```

–û–¥–Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π:
```go
type GenericRepository[T any, ID comparable] struct {
    db *sql.DB
    tableName string
}

// UserRepository
userRepo := NewRepository[User, int](db, "users")

// ProductRepository  
productRepo := NewRepository[Product, string](db, "products")
```

### Concurrent-safe —Å—Ç—Ä—É–∫—Ç—É—Ä—ã

Generic-–≤–µ—Ä—Å–∏—è –ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –∫—ç—à–∞:

```go
type Cache[K comparable, V any] struct {
    mu    sync.RWMutex
    items map[K]V
}

func (c *Cache[K, V]) Get(key K) (V, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    val, ok := c.items[key]
    return val, ok
}

func (c *Cache[K, V]) Set(key K, value V) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.items[key] = value
}
```

### –ö–æ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–∏ –ø–∞—Ç—Ç–µ—Ä–Ω—ã?

| –ü–∞—Ç—Ç–µ—Ä–Ω | –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–≥–¥–∞ |
|---------|-------------------|
| Map/Filter/Reduce | –¢—Ä–∞–Ω—Å—Ñ–æ—Ä–º–∞—Ü–∏—è –∫–æ–ª–ª–µ–∫—Ü–∏–π |
| Result | –¶–µ–ø–æ—á–∫–∞ –æ–ø–µ—Ä–∞—Ü–∏–π —Å –æ—à–∏–±–∫–∞–º–∏ |
| Optional | –ó–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–æ–≤–∞—Ç—å |
| Repository | –†–∞–±–æ—Ç–∞ —Å –ë–î –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç–µ–π |
| Generic Cache | –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–∞–Ω–Ω—ã—Ö |

### –ù–µ –ø–µ—Ä–µ—É—Å–ª–æ–∂–Ω—è–π—Ç–µ!

Generics ‚Äî –º–æ—â–Ω—ã–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, –Ω–æ –Ω–µ –Ω—É–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∏—Ö –≤–µ–∑–¥–µ:

```go
// ‚ùå –°–ª–∏—à–∫–æ–º —Å–ª–æ–∂–Ω–æ
func Process[T any, R any, F func(T) R](items []T, fn F) []R

// ‚úÖ –ü—Ä–æ—â–µ –∏ –ø–æ–Ω—è—Ç–Ω–µ–µ
func Process[T, R any](items []T, fn func(T) R) []R
```

**–ü—Ä–∞–≤–∏–ª–æ:** –µ—Å–ª–∏ Generic-–∫–æ–¥ —Å–ª–æ–∂–Ω–µ–µ –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è, —á–µ–º –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ ‚Äî –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Generics.

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ü—Ä–∏–º–µ—Ä 1: –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –Ω–∞–¥ —Å—Ä–µ–∑–∞–º–∏

```go
package slices

import "cmp"

// Map ‚Äî –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
func Map[T, R any](slice []T, fn func(T) R) []R {
    result := make([]R, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}

// Filter ‚Äî —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤
func Filter[T any](slice []T, predicate func(T) bool) []T {
    result := make([]T, 0)
    for _, v := range slice {
        if predicate(v) {
            result = append(result, v)
        }
    }
    return result
}

// Reduce ‚Äî —Å–≤—ë—Ä—Ç–∫–∞
func Reduce[T, R any](slice []T, initial R, fn func(R, T) R) R {
    result := initial
    for _, v := range slice {
        result = fn(result, v)
    }
    return result
}

// Find ‚Äî –ø–æ–∏—Å–∫ –ø–µ—Ä–≤–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
func Find[T any](slice []T, predicate func(T) bool) (T, bool) {
    for _, v := range slice {
        if predicate(v) {
            return v, true
        }
    }
    var zero T
    return zero, false
}

// Any ‚Äî —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è–µ—Ç —É—Å–ª–æ–≤–∏—é
func Any[T any](slice []T, predicate func(T) bool) bool {
    for _, v := range slice {
        if predicate(v) {
            return true
        }
    }
    return false
}

// All ‚Äî –≤—Å–µ —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—Ç —É—Å–ª–æ–≤–∏—é
func All[T any](slice []T, predicate func(T) bool) bool {
    for _, v := range slice {
        if !predicate(v) {
            return false
        }
    }
    return true
}

// GroupBy ‚Äî –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞
func GroupBy[T any, K comparable](slice []T, keyFn func(T) K) map[K][]T {
    result := make(map[K][]T)
    for _, v := range slice {
        key := keyFn(v)
        result[key] = append(result[key], v)
    }
    return result
}

// Partition ‚Äî —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ –Ω–∞ –¥–≤–µ –≥—Ä—É–ø–ø—ã
func Partition[T any](slice []T, predicate func(T) bool) (match, noMatch []T) {
    for _, v := range slice {
        if predicate(v) {
            match = append(match, v)
        } else {
            noMatch = append(noMatch, v)
        }
    }
    return
}

// FlatMap ‚Äî –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–µ–º
func FlatMap[T, R any](slice []T, fn func(T) []R) []R {
    result := make([]R, 0)
    for _, v := range slice {
        result = append(result, fn(v)...)
    }
    return result
}

// Distinct ‚Äî —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
func Distinct[T comparable](slice []T) []T {
    seen := make(map[T]bool)
    result := make([]T, 0)
    for _, v := range slice {
        if !seen[v] {
            seen[v] = true
            result = append(result, v)
        }
    }
    return result
}

// SortBy ‚Äî —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –∫–ª—é—á—É
func SortBy[T any, K cmp.Ordered](slice []T, keyFn func(T) K) {
    for i := 0; i < len(slice)-1; i++ {
        for j := i + 1; j < len(slice); j++ {
            if keyFn(slice[j]) < keyFn(slice[i]) {
                slice[i], slice[j] = slice[j], slice[i]
            }
        }
    }
}
```

```go
// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
package main

import "fmt"

type Person struct {
    Name string
    Age  int
    City string
}

func main() {
    people := []Person{
        {"Alice", 30, "NYC"},
        {"Bob", 25, "LA"},
        {"Charlie", 35, "NYC"},
        {"Diana", 28, "LA"},
    }
    
    // –ü–æ–ª—É—á–∏—Ç—å –∏–º–µ–Ω–∞
    names := Map(people, func(p Person) string {
        return p.Name
    })
    fmt.Println("Names:", names)  // [Alice Bob Charlie Diana]
    
    // –§–∏–ª—å—Ç—Ä –ø–æ –≤–æ–∑—Ä–∞—Å—Ç—É
    young := Filter(people, func(p Person) bool {
        return p.Age < 30
    })
    fmt.Println("Young:", young)
    
    // –°—É–º–º–∞ –≤–æ–∑—Ä–∞—Å—Ç–æ–≤
    totalAge := Reduce(people, 0, func(sum int, p Person) int {
        return sum + p.Age
    })
    fmt.Println("Total age:", totalAge)  // 118
    
    // –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –≥–æ—Ä–æ–¥—É
    byCity := GroupBy(people, func(p Person) string {
        return p.City
    })
    fmt.Println("By city:", byCity)
    
    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –≤–æ–∑—Ä–∞—Å—Ç—É
    SortBy(people, func(p Person) int {
        return p.Age
    })
    fmt.Println("Sorted:", people)
}
```

### –ü—Ä–∏–º–µ—Ä 2: Generic Repository

```go
package repository

import (
    "context"
    "errors"
    "sync"
)

var ErrNotFound = errors.New("entity not found")

// Entity ‚Äî –±–∞–∑–æ–≤—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —Å—É—â–Ω–æ—Å—Ç–∏
type Entity interface {
    GetID() int
}

// Repository ‚Äî –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–π
type Repository[T Entity] interface {
    Create(ctx context.Context, entity T) error
    GetByID(ctx context.Context, id int) (T, error)
    Update(ctx context.Context, entity T) error
    Delete(ctx context.Context, id int) error
    List(ctx context.Context) ([]T, error)
}

// InMemoryRepository ‚Äî —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ –ø–∞–º—è—Ç–∏
type InMemoryRepository[T Entity] struct {
    mu   sync.RWMutex
    data map[int]T
}

func NewInMemoryRepository[T Entity]() *InMemoryRepository[T] {
    return &InMemoryRepository[T]{
        data: make(map[int]T),
    }
}

func (r *InMemoryRepository[T]) Create(ctx context.Context, entity T) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.data[entity.GetID()] = entity
    return nil
}

func (r *InMemoryRepository[T]) GetByID(ctx context.Context, id int) (T, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    entity, ok := r.data[id]
    if !ok {
        var zero T
        return zero, ErrNotFound
    }
    return entity, nil
}

func (r *InMemoryRepository[T]) Update(ctx context.Context, entity T) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if _, ok := r.data[entity.GetID()]; !ok {
        return ErrNotFound
    }
    r.data[entity.GetID()] = entity
    return nil
}

func (r *InMemoryRepository[T]) Delete(ctx context.Context, id int) error {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if _, ok := r.data[id]; !ok {
        return ErrNotFound
    }
    delete(r.data, id)
    return nil
}

func (r *InMemoryRepository[T]) List(ctx context.Context) ([]T, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    result := make([]T, 0, len(r.data))
    for _, entity := range r.data {
        result = append(result, entity)
    }
    return result, nil
}
```

```go
// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
type User struct {
    ID    int
    Name  string
    Email string
}

func (u User) GetID() int { return u.ID }

func main() {
    ctx := context.Background()
    
    userRepo := NewInMemoryRepository[User]()
    
    // Create
    userRepo.Create(ctx, User{ID: 1, Name: "Alice", Email: "alice@example.com"})
    userRepo.Create(ctx, User{ID: 2, Name: "Bob", Email: "bob@example.com"})
    
    // Read
    user, err := userRepo.GetByID(ctx, 1)
    if err == nil {
        fmt.Printf("Found: %+v\n", user)
    }
    
    // List
    users, _ := userRepo.List(ctx)
    fmt.Printf("All users: %+v\n", users)
}
```

### –ü—Ä–∏–º–µ—Ä 3: Type-safe Event Bus

```go
package events

import (
    "sync"
)

// Event ‚Äî –æ–±–æ–±—â—ë–Ω–Ω–æ–µ —Å–æ–±—ã—Ç–∏–µ
type Event[T any] struct {
    Data T
}

// Handler ‚Äî –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ —Å–æ–±—ã—Ç–∏—è
type Handler[T any] func(Event[T])

// EventBus ‚Äî —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–∞—è —à–∏–Ω–∞ —Å–æ–±—ã—Ç–∏–π
type EventBus[T any] struct {
    mu       sync.RWMutex
    handlers []Handler[T]
}

func NewEventBus[T any]() *EventBus[T] {
    return &EventBus[T]{
        handlers: make([]Handler[T], 0),
    }
}

func (eb *EventBus[T]) Subscribe(handler Handler[T]) {
    eb.mu.Lock()
    defer eb.mu.Unlock()
    eb.handlers = append(eb.handlers, handler)
}

func (eb *EventBus[T]) Publish(data T) {
    eb.mu.RLock()
    handlers := make([]Handler[T], len(eb.handlers))
    copy(handlers, eb.handlers)
    eb.mu.RUnlock()
    
    event := Event[T]{Data: data}
    for _, handler := range handlers {
        handler(event)
    }
}

func (eb *EventBus[T]) PublishAsync(data T) {
    eb.mu.RLock()
    handlers := make([]Handler[T], len(eb.handlers))
    copy(handlers, eb.handlers)
    eb.mu.RUnlock()
    
    event := Event[T]{Data: data}
    for _, handler := range handlers {
        go handler(event)
    }
}
```

```go
// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
type OrderCreated struct {
    OrderID int
    UserID  int
    Amount  float64
}

type UserRegistered struct {
    UserID int
    Email  string
}

func main() {
    // –®–∏–Ω–∞ –¥–ª—è —Å–æ–±—ã—Ç–∏–π –∑–∞–∫–∞–∑–æ–≤
    orderBus := NewEventBus[OrderCreated]()
    
    orderBus.Subscribe(func(e Event[OrderCreated]) {
        fmt.Printf("Order %d created for user %d\n", e.Data.OrderID, e.Data.UserID)
    })
    
    orderBus.Subscribe(func(e Event[OrderCreated]) {
        fmt.Printf("Sending email for order %d\n", e.Data.OrderID)
    })
    
    orderBus.Publish(OrderCreated{OrderID: 1, UserID: 100, Amount: 99.99})
    
    // –®–∏–Ω–∞ –¥–ª—è —Å–æ–±—ã—Ç–∏–π —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
    userBus := NewEventBus[UserRegistered]()
    
    userBus.Subscribe(func(e Event[UserRegistered]) {
        fmt.Printf("Welcome email to %s\n", e.Data.Email)
    })
    
    userBus.Publish(UserRegistered{UserID: 1, Email: "user@example.com"})
}
```

### –ü—Ä–∏–º–µ—Ä 4: Generic Pool

```go
package pool

import (
    "sync"
)

// Pool ‚Äî –æ–±–æ–±—â—ë–Ω–Ω—ã–π –ø—É–ª –æ–±—ä–µ–∫—Ç–æ–≤
type Pool[T any] struct {
    pool    sync.Pool
    factory func() T
    reset   func(T)
}

func NewPool[T any](factory func() T, reset func(T)) *Pool[T] {
    p := &Pool[T]{
        factory: factory,
        reset:   reset,
    }
    p.pool.New = func() interface{} {
        return factory()
    }
    return p
}

func (p *Pool[T]) Get() T {
    return p.pool.Get().(T)
}

func (p *Pool[T]) Put(item T) {
    if p.reset != nil {
        p.reset(item)
    }
    p.pool.Put(item)
}
```

```go
// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
import "bytes"

func main() {
    // –ü—É–ª –±—É—Ñ–µ—Ä–æ–≤
    bufferPool := NewPool(
        func() *bytes.Buffer {
            return new(bytes.Buffer)
        },
        func(b *bytes.Buffer) {
            b.Reset()
        },
    )
    
    buf := bufferPool.Get()
    buf.WriteString("Hello, World!")
    fmt.Println(buf.String())
    bufferPool.Put(buf)
    
    // –ü—É–ª —Å—Ä–µ–∑–æ–≤
    slicePool := NewPool(
        func() []byte {
            return make([]byte, 0, 1024)
        },
        func(s []byte) {
            // –û—á–∏—â–∞–µ–º —Å—Ä–µ–∑
        },
    )
    
    slice := slicePool.Get()
    slice = append(slice, []byte("data")...)
    slicePool.Put(slice[:0])
}
```

### –ü—Ä–∏–º–µ—Ä 5: Builder Pattern

```go
package builder

// Builder ‚Äî –æ–±–æ–±—â—ë–Ω–Ω—ã–π —Å—Ç—Ä–æ–∏—Ç–µ–ª—å
type Builder[T any] struct {
    value T
}

func NewBuilder[T any](initial T) *Builder[T] {
    return &Builder[T]{value: initial}
}

func (b *Builder[T]) With(modifier func(*T)) *Builder[T] {
    modifier(&b.value)
    return b
}

func (b *Builder[T]) Build() T {
    return b.value
}

// –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø—Ä–∏–º–µ—Ä
type Config struct {
    Host     string
    Port     int
    Timeout  int
    Debug    bool
    LogLevel string
}

func DefaultConfig() Config {
    return Config{
        Host:     "localhost",
        Port:     8080,
        Timeout:  30,
        Debug:    false,
        LogLevel: "info",
    }
}

func main() {
    config := NewBuilder(DefaultConfig()).
        With(func(c *Config) { c.Host = "0.0.0.0" }).
        With(func(c *Config) { c.Port = 3000 }).
        With(func(c *Config) { c.Debug = true }).
        Build()
    
    fmt.Printf("%+v\n", config)
}
```

### –ü—Ä–∏–º–µ—Ä 6: Cache —Å TTL

```go
package cache

import (
    "sync"
    "time"
)

type cacheItem[V any] struct {
    value      V
    expiration time.Time
}

type Cache[K comparable, V any] struct {
    mu    sync.RWMutex
    items map[K]cacheItem[V]
    ttl   time.Duration
}

func NewCache[K comparable, V any](ttl time.Duration) *Cache[K, V] {
    c := &Cache[K, V]{
        items: make(map[K]cacheItem[V]),
        ttl:   ttl,
    }
    
    // –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö
    go c.cleanup()
    
    return c
}

func (c *Cache[K, V]) Set(key K, value V) {
    c.mu.Lock()
    defer c.mu.Unlock()
    
    c.items[key] = cacheItem[V]{
        value:      value,
        expiration: time.Now().Add(c.ttl),
    }
}

func (c *Cache[K, V]) Get(key K) (V, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    
    item, ok := c.items[key]
    if !ok || time.Now().After(item.expiration) {
        var zero V
        return zero, false
    }
    
    return item.value, true
}

func (c *Cache[K, V]) Delete(key K) {
    c.mu.Lock()
    defer c.mu.Unlock()
    delete(c.items, key)
}

func (c *Cache[K, V]) cleanup() {
    ticker := time.NewTicker(c.ttl / 2)
    for range ticker.C {
        c.mu.Lock()
        now := time.Now()
        for key, item := range c.items {
            if now.After(item.expiration) {
                delete(c.items, key)
            }
        }
        c.mu.Unlock()
    }
}
```

### –ü—Ä–∏–º–µ—Ä 7: Pipe Pattern

```go
package pipe

// Stage ‚Äî —ç—Ç–∞–ø –æ–±—Ä–∞–±–æ—Ç–∫–∏
type Stage[In, Out any] func(In) Out

// Pipe ‚Äî —Ü–µ–ø–æ—á–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏
func Pipe[A, B, C any](
    stage1 Stage[A, B],
    stage2 Stage[B, C],
) Stage[A, C] {
    return func(input A) C {
        return stage2(stage1(input))
    }
}

// Pipe3 ‚Äî —Ç—Ä–∏ —ç—Ç–∞–ø–∞
func Pipe3[A, B, C, D any](
    s1 Stage[A, B],
    s2 Stage[B, C],
    s3 Stage[C, D],
) Stage[A, D] {
    return func(input A) D {
        return s3(s2(s1(input)))
    }
}
```

```go
// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ
func main() {
    // –≠—Ç–∞–ø—ã –æ–±—Ä–∞–±–æ—Ç–∫–∏
    parseInt := func(s string) int {
        n, _ := strconv.Atoi(s)
        return n
    }
    
    double := func(n int) int {
        return n * 2
    }
    
    toString := func(n int) string {
        return fmt.Sprintf("Result: %d", n)
    }
    
    // –°–æ–±–∏—Ä–∞–µ–º pipeline
    process := Pipe3(parseInt, double, toString)
    
    result := process("21")
    fmt.Println(result)  // Result: 42
}
```

---

## ‚ö†Ô∏è –ö–æ–≥–¥–∞ –ù–ï –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å Generics

```go
// ‚ùå –ù–ï –ù–£–ñ–ù–û ‚Äî –æ–¥–∏–Ω –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø
func SumInts(nums []int) int { ... }

// ‚ùå –ü–ï–†–ï–£–°–õ–û–ñ–ù–ï–ù–ò–ï ‚Äî –ø—Ä–æ—Å—Ç–∞—è —Ñ—É–Ω–∫—Ü–∏—è
func Generic[T any](x T) T { return x }  // –∑–∞—á–µ–º?

// ‚ùå –ö–û–ì–î–ê interface{} –î–û–°–¢–ê–¢–û–ß–ù–û
func Log(v interface{}) { fmt.Println(v) }
```

---

## üèãÔ∏è –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ –∑–∞–¥–∞–Ω–∏—è

### –ó–∞–¥–∞–Ω–∏–µ 1: Generic Reduce

–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é —Å–≤—ë—Ä—Ç–∫–∏ (reduce/fold).

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import "fmt"

// TODO: –°–æ–∑–¥–∞–π—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–¥–∞–Ω–∏—é

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
Sum: 15
Product: 120
Sentence: Hello World Go
Max: 5
```

**–ë–∞–ª–ª—ã:** 15

### –ó–∞–¥–∞–Ω–∏–µ 2: Lazy Initialization

–°–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø –¥–ª—è –ª–µ–Ω–∏–≤–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏.

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import "fmt"

// TODO: –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–µ—à–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–¥–∞–Ω–∏—é

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
Before first Get
Loading config...
Host: localhost
Port: 8080
```

**–ë–∞–ª–ª—ã:** 10

### –ó–∞–¥–∞–Ω–∏–µ 3: Event Bus

–†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ç–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—É—é —à–∏–Ω—É —Å–æ–±—ã—Ç–∏–π.

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import "fmt"

// TODO: –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–µ—à–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–¥–∞–Ω–∏—é

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
Send welcome email to Alice
Log: user 1 created
Process payment for order 100: $99.99
```

**–ë–∞–ª–ª—ã:** 15

### –ó–∞–¥–∞–Ω–∏–µ 4: Builder Pattern

–°–æ–∑–¥–∞–π—Ç–µ —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π builder.

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import "fmt"

// TODO: –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–µ—à–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–¥–∞–Ω–∏—é

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
Server config: {Host:0.0.0.0 Port:3000 ReadTimeout:30 WriteTimeout:30 MaxConns:1000 Debug:true}
```

**–ë–∞–ª–ª—ã:** 10

### –ó–∞–¥–∞–Ω–∏–µ 5: Cache —Å TTL

–°–æ–∑–¥–∞–π—Ç–µ –∫—ç—à —Å –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏ –∑–∞–ø–∏—Å–µ–π.

**–ù–∞—á–∞–ª—å–Ω—ã–π –∫–æ–¥:**
```go
package main

import "fmt"

// TODO: –†–µ–∞–ª–∏–∑—É–π—Ç–µ —Ä–µ—à–µ–Ω–∏–µ —Å–æ–≥–ª–∞—Å–Ω–æ –∑–∞–¥–∞–Ω–∏—é

func main() {
    // –í–∞—à –∫–æ–¥ –∑–¥–µ—Å—å
    
}
```

**–û–∂–∏–¥–∞–µ–º—ã–π –≤—ã–≤–æ–¥:**
```
Immediately: 42, ok=true
After 50ms: 42, ok=true
After 150ms: 0, ok=false
```

**–ë–∞–ª–ª—ã:** 15

---

## üîó –ü–æ–ª–µ–∑–Ω—ã–µ —Å—Å—ã–ª–∫–∏

- [Go Generics Patterns](https://go.dev/blog/when-generics)
- [Effective Go Generics](https://go.dev/doc/tutorial/generics)
