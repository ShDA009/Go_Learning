# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–∏–ø–∞ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ (Type Assertion & Type Switch)

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **Type Assertion** ‚Äî –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Ç–∏–ø–∞ –∏–∑ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
2. **Type Switch** ‚Äî –≤–µ—Ç–≤–ª–µ–Ω–∏–µ –ø–æ —Ç–∏–ø—É –∑–Ω–∞—á–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
3. **–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞** ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –¥–≤—É—Ö –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π (value, ok)
4. **Panic** ‚Äî –Ω–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –≤—ã–∑—ã–≤–∞–µ—Ç panic –ø—Ä–∏ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏
5. **–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ** ‚Äî –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –≤ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏—è—Ö

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### Type Assertion (—É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç–∏–ø–∞)

```go
// –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ ‚Äî panic –ø—Ä–∏ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏
value := interfaceVar.(ConcreteType)

// –ë–µ–∑–æ–ø–∞—Å–Ω–æ ‚Äî ok = false –ø—Ä–∏ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏
value, ok := interfaceVar.(ConcreteType)
if ok {
    // –∏—Å–ø–æ–ª—å–∑—É–µ–º value
}
```

### Type Switch (–ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å —Ç–∏–ø–∞)

```go
switch v := interfaceVar.(type) {
case Type1:
    // v –∏–º–µ–µ—Ç —Ç–∏–ø Type1
case Type2:
    // v –∏–º–µ–µ—Ç —Ç–∏–ø Type2
default:
    // —Ç–∏–ø –Ω–µ —Å–æ–≤–ø–∞–ª
}
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ë–∞–∑–æ–≤—ã–π Type Assertion

```go
package main

import "fmt"

func main() {
    var i interface{} = "Hello, World!"
    
    // –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç–∏–ø–∞
    str, ok := i.(string)
    if ok {
        fmt.Println("String value:", str)
        fmt.Println("Length:", len(str))
    }
    
    // –ü–æ–ø—ã—Ç–∫–∞ –∏–∑–≤–ª–µ—á—å –Ω–µ–≤–µ—Ä–Ω—ã–π —Ç–∏–ø
    num, ok := i.(int)
    if !ok {
        fmt.Println("Not an int, got zero value:", num)  // 0
    }
    
    // –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ (panic –ø—Ä–∏ –Ω–µ—Å–æ–≤–ø–∞–¥–µ–Ω–∏–∏)
    // num := i.(int)  // PANIC: interface conversion: interface {} is string, not int
}
```

### Type Switch ‚Äî –æ—Å–Ω–æ–≤—ã

```go
package main

import "fmt"

func describe(i interface{}) {
    switch v := i.(type) {
    case int:
        fmt.Printf("Integer: %d (doubled: %d)\n", v, v*2)
    case float64:
        fmt.Printf("Float: %.2f (squared: %.2f)\n", v, v*v)
    case string:
        fmt.Printf("String: %q (length: %d)\n", v, len(v))
    case bool:
        fmt.Printf("Boolean: %t\n", v)
    case nil:
        fmt.Println("Nil value")
    default:
        fmt.Printf("Unknown type: %T\n", v)
    }
}

func main() {
    describe(42)
    describe(3.14)
    describe("Hello")
    describe(true)
    describe(nil)
    describe([]int{1, 2, 3})
}
```

### –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞

```go
package main

import "fmt"

type Stringer interface {
    String() string
}

type Person struct {
    Name string
    Age  int
}

func (p Person) String() string {
    return fmt.Sprintf("%s (%d)", p.Name, p.Age)
}

type Number int  // –Ω–µ —Ä–µ–∞–ª–∏–∑—É–µ—Ç Stringer

func printIfStringer(v interface{}) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Ä–µ–∞–ª–∏–∑—É–µ—Ç –ª–∏ v –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å Stringer
    if s, ok := v.(Stringer); ok {
        fmt.Println("Stringer:", s.String())
    } else {
        fmt.Printf("Not a Stringer: %v\n", v)
    }
}

func main() {
    p := Person{Name: "Alice", Age: 30}
    n := Number(42)
    
    printIfStringer(p)  // Stringer: Alice (30)
    printIfStringer(n)  // Not a Stringer: 42
}
```

### Type Switch —Å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞–º–∏

```go
package main

import "fmt"

type Reader interface {
    Read() string
}

type Writer interface {
    Write(data string)
}

type ReadWriter interface {
    Reader
    Writer
}

type File struct {
    content string
}

func (f *File) Read() string       { return f.content }
func (f *File) Write(data string)  { f.content = data }

type Console struct{}

func (c Console) Write(data string) { fmt.Println(data) }

func process(v interface{}) {
    switch obj := v.(type) {
    case ReadWriter:
        fmt.Println("ReadWriter detected")
        obj.Write("Hello")
        fmt.Println("Read:", obj.Read())
    case Reader:
        fmt.Println("Reader only:", obj.Read())
    case Writer:
        fmt.Println("Writer only")
        obj.Write("Output")
    default:
        fmt.Println("Unknown type")
    }
}

func main() {
    file := &File{content: "File content"}
    console := Console{}
    
    process(file)     // ReadWriter
    process(console)  // Writer only
    process("string") // Unknown type
}
```

### –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–∏–ø–æ–≤ –≤ –æ–¥–Ω–æ–º case

```go
package main

import "fmt"

func classify(v interface{}) {
    switch v.(type) {
    case int, int8, int16, int32, int64:
        fmt.Println("Signed integer")
    case uint, uint8, uint16, uint32, uint64:
        fmt.Println("Unsigned integer")
    case float32, float64:
        fmt.Println("Floating point")
    case string:
        fmt.Println("String")
    case bool:
        fmt.Println("Boolean")
    default:
        fmt.Printf("Other: %T\n", v)
    }
}

func main() {
    classify(int32(42))
    classify(uint64(100))
    classify(3.14)
    classify("hello")
    classify(true)
    classify([]int{})
}
```

### –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–∏–º–µ—Ä: JSON-like –ø–∞—Ä—Å–µ—Ä

```go
package main

import "fmt"

// –û–±—Ä–∞–±–æ—Ç–∫–∞ JSON-–ø–æ–¥–æ–±–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
func processJSON(data interface{}) {
    switch v := data.(type) {
    case map[string]interface{}:
        fmt.Println("Object:")
        for key, value := range v {
            fmt.Printf("  %s: ", key)
            processJSON(value)
        }
    case []interface{}:
        fmt.Println("Array:")
        for i, item := range v {
            fmt.Printf("  [%d]: ", i)
            processJSON(item)
        }
    case string:
        fmt.Printf("String: %q\n", v)
    case float64:
        fmt.Printf("Number: %v\n", v)
    case bool:
        fmt.Printf("Boolean: %v\n", v)
    case nil:
        fmt.Println("Null")
    default:
        fmt.Printf("Unknown: %T\n", v)
    }
}

func main() {
    data := map[string]interface{}{
        "name": "Alice",
        "age":  float64(30),
        "active": true,
        "tags": []interface{}{"go", "developer"},
        "address": map[string]interface{}{
            "city": "Moscow",
        },
    }
    
    processJSON(data)
}
```

### –£—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –¥–ª—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ Movable

```go
package main

import "fmt"

type Movable interface {
    Move()
}

type Car struct {
    Model string
    Speed int
}

func (c Car) Move() {
    fmt.Printf("%s drives at %d km/h\n", c.Model, c.Speed)
}

type Plane struct {
    Model    string
    Altitude int
}

func (p Plane) Move() {
    fmt.Printf("%s flies at %d meters\n", p.Model, p.Altitude)
}

func getDetails(m Movable) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Ç–∏–ø
    if car, ok := m.(Car); ok {
        fmt.Printf("Car: %s, Max speed: %d\n", car.Model, car.Speed)
        return
    }
    
    if plane, ok := m.(Plane); ok {
        fmt.Printf("Plane: %s, Cruising altitude: %d\n", plane.Model, plane.Altitude)
        return
    }
    
    fmt.Println("Unknown vehicle")
}

func main() {
    vehicles := []Movable{
        Car{Model: "Tesla", Speed: 250},
        Plane{Model: "Boeing", Altitude: 10000},
    }
    
    for _, v := range vehicles {
        v.Move()
        getDetails(v)
        fmt.Println()
    }
}
```

### –ü–∞—Ç—Ç–µ—Ä–Ω: –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –ø–æ —Ç–∏–ø—É

```go
package main

import (
    "errors"
    "fmt"
)

// –ö–∞—Å—Ç–æ–º–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫
type ValidationError struct {
    Field   string
    Message string
}

func (e ValidationError) Error() string {
    return fmt.Sprintf("validation error on %s: %s", e.Field, e.Message)
}

type NotFoundError struct {
    Resource string
}

func (e NotFoundError) Error() string {
    return fmt.Sprintf("%s not found", e.Resource)
}

func handleError(err error) {
    if err == nil {
        return
    }
    
    switch e := err.(type) {
    case ValidationError:
        fmt.Printf("Please fix field '%s': %s\n", e.Field, e.Message)
    case NotFoundError:
        fmt.Printf("Could not find: %s\n", e.Resource)
    default:
        fmt.Printf("General error: %v\n", err)
    }
}

func main() {
    errors := []error{
        ValidationError{Field: "email", Message: "invalid format"},
        NotFoundError{Resource: "User #123"},
        errors.New("something went wrong"),
    }
    
    for _, err := range errors {
        handleError(err)
    }
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ù–µ–±–µ–∑–æ–ø–∞—Å–Ω–æ–µ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç–∏–ø–∞

```go
var i interface{} = "hello"

// ‚ùå PANIC –µ—Å–ª–∏ —Ç–∏–ø –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç
num := i.(int)

// ‚úÖ –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
if num, ok := i.(int); ok {
    fmt.Println(num)
} else {
    fmt.Println("Not an int")
}
```

### 2. –ó–∞–±—ã–ª–∏ –ø—Ä–æ nil

```go
var i interface{}  // nil

// ‚ùå PANIC
// _ = i.(string)

// ‚úÖ –ü—Ä–æ–≤–µ—Ä—è–µ–º nil
if i != nil {
    if s, ok := i.(string); ok {
        fmt.Println(s)
    }
}

// –ò–ª–∏ –≤ type switch
switch v := i.(type) {
case nil:
    fmt.Println("nil value")
case string:
    fmt.Println(v)
}
```

### 3. –ü–æ—Ä—è–¥–æ–∫ case –≤ type switch –≤–∞–∂–µ–Ω

```go
type Reader interface { Read() }
type ReadWriter interface { 
    Read()
    Write()
}

func process(v interface{}) {
    // ‚ùå Reader –≤—Å–µ–≥–¥–∞ —Å–æ–≤–ø–∞–¥—ë—Ç –ø–µ—Ä–≤—ã–º, –¥–∞–∂–µ –¥–ª—è ReadWriter
    switch v.(type) {
    case Reader:
        fmt.Println("Reader")
    case ReadWriter:
        fmt.Println("ReadWriter")  // –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—Å—è!
    }
    
    // ‚úÖ –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º –±–æ–ª–µ–µ —Å–ø–µ—Ü–∏—Ñ–∏—á–Ω—ã–π —Ç–∏–ø
    switch v.(type) {
    case ReadWriter:
        fmt.Println("ReadWriter")
    case Reader:
        fmt.Println("Reader")
    }
}
```

### 4. –£—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –¥–ª—è –Ω–µ-–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞

```go
str := "hello"

// ‚ùå –û–®–ò–ë–ö–ê –ö–û–ú–ü–ò–õ–Ø–¶–ò–ò ‚Äî str –Ω–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
// _ = str.(int)

// ‚úÖ –°–Ω–∞—á–∞–ª–∞ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤ interface{}
var i interface{} = str
_, ok := i.(int)
fmt.Println(ok)  // false
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞—á–∞ 1: –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `SafeString(v interface{}) string`, –∫–æ—Ç–æ—Ä–∞—è –±–µ–∑–æ–ø–∞—Å–Ω–æ –∏–∑–≤–ª–µ–∫–∞–µ—Ç —Å—Ç—Ä–æ–∫—É –∏–ª–∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—É—Å—Ç—É—é —Å—Ç—Ä–æ–∫—É.

### –ó–∞–¥–∞—á–∞ 2: –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `Calculate(a, b, op interface{}) (float64, error)`, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–ø–æ–ª–Ω—è–µ—Ç –æ–ø–µ—Ä–∞—Ü–∏—é op (+, -, *, /) –Ω–∞–¥ —á–∏—Å–ª–∞–º–∏ –ª—é–±–æ–≥–æ —Ç–∏–ø–∞.

### –ó–∞–¥–∞—á–∞ 3: –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `Format(v interface{}) string`, –∫–æ—Ç–æ—Ä–∞—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –µ–≥–æ —Ç–∏–ø–∞ (—á–∏—Å–ª–∞ —Å 2 –∑–Ω–∞–∫–∞–º–∏, —Å—Ç—Ä–æ–∫–∏ –≤ –∫–∞–≤—ã—á–∫–∞—Ö, bool –∫–∞–∫ "–¥–∞/–Ω–µ—Ç").

### –ó–∞–¥–∞—á–∞ 4: –°—É–º–º–∞
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `Sum(values ...interface{}) float64`, –∫–æ—Ç–æ—Ä–∞—è —Å—É–º–º–∏—Ä—É–µ—Ç –≤—Å–µ —á–∏—Å–ª–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è, –∏–≥–Ω–æ—Ä–∏—Ä—É—è –æ—Å—Ç–∞–ª—å–Ω—ã–µ.

### –ó–∞–¥–∞—á–∞ 5: –¢–∏–ø–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –æ—à–∏–±–∫–∏
–°–æ–∑–¥–∞–π—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–∏–ø–æ–≤ –æ—à–∏–±–æ–∫ (AuthError, DatabaseError, NetworkError) –∏ —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –∏—Ö –æ–±—Ä–∞–±–æ—Ç–∫–∏ —á–µ—Ä–µ–∑ type switch.

### –ó–∞–¥–∞—á–∞ 6: –°–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `ToMap(v interface{}) map[string]interface{}`, –∫–æ—Ç–æ—Ä–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤ map (–∏—Å–ø–æ–ª—å–∑—É—è —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –∏–ª–∏ type switch).

### –ó–∞–¥–∞—á–∞ 7: –í–∞–ª–∏–¥–∞—Ç–æ—Ä
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–∏–Ω–∏–º–∞–µ—Ç interface{} –∏ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —Ä–µ–∞–ª–∏–∑—É–µ—Ç –ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã Stringer, error, fmt.Formatter.

### –ó–∞–¥–∞—á–∞ 8: –ì–ª—É–±–æ–∫–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
–ù–∞–ø–∏—à–∏—Ç–µ —Ñ—É–Ω–∫—Ü–∏—é `DeepEqual(a, b interface{}) bool`, –∫–æ—Ç–æ—Ä–∞—è —Å—Ä–∞–≤–Ω–∏–≤–∞–µ—Ç –¥–≤–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Å —É—á—ë—Ç–æ–º –∏—Ö —Ç–∏–ø–æ–≤.
