# –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **database/sql** ‚Äî —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –±–∞–∑ –¥–∞–Ω–Ω—ã—Ö
2. **Driver** ‚Äî –¥—Ä–∞–π–≤–µ—Ä –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –°–£–ë–î (MySQL, PostgreSQL –∏ —Ç.–¥.)
3. **sql.Open** ‚Äî —Å–æ–∑–¥–∞–Ω–∏–µ –ø—É–ª–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
4. **db.Query** ‚Äî –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ SELECT –∑–∞–ø—Ä–æ—Å–æ–≤
5. **rows.Scan** ‚Äî –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ

```go
import (
    "database/sql"
    _ "github.com/go-sql-driver/mysql"
)

db, err := sql.Open("mysql", "user:password@tcp(host:port)/dbname")
defer db.Close()
```

### –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

```go
rows, err := db.Query("SELECT id, name FROM users")
defer rows.Close()

for rows.Next() {
    var id int
    var name string
    rows.Scan(&id, &name)
}
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ù–∞—Å—Ç—Ä–æ–π–∫–∞ MySQL

```sql
-- –°–æ–∑–¥–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
CREATE DATABASE productdb;
USE productdb;

-- –°–æ–∑–¥–∞–Ω–∏–µ —Ç–∞–±–ª–∏—Ü—ã
CREATE TABLE products (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    price INT NOT NULL
);

-- –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
INSERT INTO products (name, price) VALUES
    ('iPhone', 999),
    ('MacBook', 1999),
    ('iPad', 799);
```

### –ë–∞–∑–æ–≤–æ–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∏ –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö

```go
package main

import (
    "database/sql"
    "fmt"
    "html/template"
    "net/http"
    
    _ "github.com/go-sql-driver/mysql"
)

type Product struct {
    ID    int
    Name  string
    Price int
}

var database *sql.DB

func main() {
    var err error
    database, err = sql.Open("mysql", "root:password@tcp(localhost:3306)/productdb")
    if err != nil {
        panic(err)
    }
    defer database.Close()
    
    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    if err = database.Ping(); err != nil {
        panic(err)
    }
    
    http.HandleFunc("/", indexHandler)
    
    fmt.Println("Server started at :8080")
    http.ListenAndServe(":8080", nil)
}

func indexHandler(w http.ResponseWriter, r *http.Request) {
    rows, err := database.Query("SELECT id, name, price FROM products")
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    defer rows.Close()
    
    var products []Product
    for rows.Next() {
        var p Product
        err := rows.Scan(&p.ID, &p.Name, &p.Price)
        if err != nil {
            http.Error(w, err.Error(), 500)
            return
        }
        products = append(products, p)
    }
    
    tmpl := template.Must(template.ParseFiles("templates/index.html"))
    tmpl.Execute(w, products)
}
```

### HTML —à–∞–±–ª–æ–Ω –¥–ª—è —Å–ø–∏—Å–∫–∞

**templates/index.html:**
```html
<!DOCTYPE html>
<html>
<head>
    <title>Products</title>
    <style>
        table { border-collapse: collapse; width: 100%; max-width: 600px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4CAF50; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
    </style>
</head>
<body>
    <h1>Products</h1>
    
    {{ if . }}
    <table>
        <tr>
            <th>ID</th>
            <th>Name</th>
            <th>Price</th>
        </tr>
        {{ range . }}
        <tr>
            <td>{{ .ID }}</td>
            <td>{{ .Name }}</td>
            <td>${{ .Price }}</td>
        </tr>
        {{ end }}
    </table>
    {{ else }}
    <p>No products found</p>
    {{ end }}
</body>
</html>
```

### –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–¥–Ω–æ–π –∑–∞–ø–∏—Å–∏ (QueryRow)

```go
package main

import (
    "database/sql"
    "fmt"
    "html/template"
    "net/http"
    
    "github.com/gorilla/mux"
    _ "github.com/go-sql-driver/mysql"
)

type Product struct {
    ID    int
    Name  string
    Price int
}

var database *sql.DB

func main() {
    var err error
    database, err = sql.Open("mysql", "root:password@tcp(localhost:3306)/productdb")
    if err != nil {
        panic(err)
    }
    defer database.Close()
    
    router := mux.NewRouter()
    router.HandleFunc("/product/{id:[0-9]+}", productHandler)
    
    http.ListenAndServe(":8080", router)
}

func productHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    
    var p Product
    err := database.QueryRow("SELECT id, name, price FROM products WHERE id = ?", id).
        Scan(&p.ID, &p.Name, &p.Price)
    
    if err == sql.ErrNoRows {
        http.NotFound(w, r)
        return
    }
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    
    tmpl := template.Must(template.New("product").Parse(`
<!DOCTYPE html>
<html>
<body>
    <h1>{{ .Name }}</h1>
    <p>ID: {{ .ID }}</p>
    <p>Price: ${{ .Price }}</p>
    <a href="/">Back to list</a>
</body>
</html>
    `))
    
    tmpl.Execute(w, p)
}
```

### –ü–æ–∏—Å–∫ –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º

```go
func searchHandler(w http.ResponseWriter, r *http.Request) {
    query := r.URL.Query().Get("q")
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º LIKE –¥–ª—è –ø–æ–∏—Å–∫–∞
    rows, err := database.Query(
        "SELECT id, name, price FROM products WHERE name LIKE ?",
        "%"+query+"%",
    )
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    defer rows.Close()
    
    var products []Product
    for rows.Next() {
        var p Product
        rows.Scan(&p.ID, &p.Name, &p.Price)
        products = append(products, p)
    }
    
    tmpl := template.Must(template.ParseFiles("templates/search.html"))
    tmpl.Execute(w, map[string]interface{}{
        "Query":    query,
        "Products": products,
    })
}
```

### –ü–æ–ª–Ω—ã–π –ø—Ä–∏–º–µ—Ä —Å –Ω–∞–≤–∏–≥–∞—Ü–∏–µ–π

```go
package main

import (
    "database/sql"
    "fmt"
    "html/template"
    "net/http"
    
    "github.com/gorilla/mux"
    _ "github.com/go-sql-driver/mysql"
)

type Product struct {
    ID    int
    Name  string
    Price int
}

var (
    database  *sql.DB
    templates *template.Template
)

func main() {
    var err error
    
    // –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –ë–î
    database, err = sql.Open("mysql", "root:password@tcp(localhost:3306)/productdb")
    if err != nil {
        panic(err)
    }
    defer database.Close()
    
    // –ó–∞–≥—Ä—É–∑–∫–∞ —à–∞–±–ª–æ–Ω–æ–≤
    templates = template.Must(template.ParseGlob("templates/*.html"))
    
    // –†–æ—É—Ç–∏–Ω–≥
    router := mux.NewRouter()
    router.HandleFunc("/", listHandler).Methods("GET")
    router.HandleFunc("/product/{id:[0-9]+}", viewHandler).Methods("GET")
    
    fmt.Println("Server started at :8080")
    http.ListenAndServe(":8080", router)
}

func listHandler(w http.ResponseWriter, r *http.Request) {
    rows, err := database.Query("SELECT id, name, price FROM products ORDER BY name")
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    defer rows.Close()
    
    var products []Product
    for rows.Next() {
        var p Product
        rows.Scan(&p.ID, &p.Name, &p.Price)
        products = append(products, p)
    }
    
    templates.ExecuteTemplate(w, "list.html", products)
}

func viewHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    
    var p Product
    err := database.QueryRow("SELECT id, name, price FROM products WHERE id = ?", id).
        Scan(&p.ID, &p.Name, &p.Price)
    
    if err == sql.ErrNoRows {
        http.NotFound(w, r)
        return
    }
    if err != nil {
        http.Error(w, err.Error(), 500)
        return
    }
    
    templates.ExecuteTemplate(w, "view.html", p)
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ù–µ –∑–∞–∫—Ä—ã–≤–∞—é—Ç rows

```go
// ‚ùå –£—Ç–µ—á–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–π
rows, _ := db.Query("SELECT ...")
for rows.Next() { ... }

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ defer
rows, err := db.Query("SELECT ...")
defer rows.Close()
```

### 2. SQL –∏–Ω—ä–µ–∫—Ü–∏–∏

```go
// ‚ùå –£—è–∑–≤–∏–º–æ –∫ SQL injection
query := "SELECT * FROM users WHERE id = " + id
db.Query(query)

// ‚úÖ –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–ª–µ–π—Å—Ö–æ–ª–¥–µ—Ä—ã
db.Query("SELECT * FROM users WHERE id = ?", id)
```

### 3. –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ Scan

```go
// ‚ùå –ü–æ—Ä—è–¥–æ–∫ –¥–æ–ª–∂–µ–Ω —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å SELECT
rows.Scan(&name, &id)  // SELECT id, name

// ‚úÖ –¢–æ—Ç –∂–µ –ø–æ—Ä—è–¥–æ–∫
rows.Scan(&id, &name)  // SELECT id, name
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞—á–∞ 1: Product catalog
–ö–∞—Ç–∞–ª–æ–≥ —Ç–æ–≤–∞—Ä–æ–≤ —Å –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º–∏.

### –ó–∞–¥–∞—á–∞ 2: User list
–°–ø–∏—Å–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π.

### –ó–∞–¥–∞—á–∞ 3: Search
–ü–æ–∏—Å–∫ –ø–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –ø–æ–ª—è–º.

### –ó–∞–¥–∞—á–∞ 4: Sorting
–°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ä–∞–∑–Ω—ã–º –ø–æ–ª—è–º.

### –ó–∞–¥–∞—á–∞ 5: Filtering
–§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—è–º.

### –ó–∞–¥–∞—á–∞ 6: Statistics
–°—Ç—Ä–∞–Ω–∏—Ü–∞ —Å–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π (COUNT, SUM).

### –ó–∞–¥–∞—á–∞ 7: Relations
–í—ã–≤–æ–¥ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (JOIN).

### –ó–∞–¥–∞—á–∞ 8: Export
–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ CSV.
