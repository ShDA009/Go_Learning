# –°—Ç—Ä–æ–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ä–º

## üí° –ö–ª—é—á–µ–≤—ã–µ –∏–¥–µ–∏

1. **Query –ø–∞—Ä–∞–º–µ—Ç—Ä—ã** ‚Äî –¥–∞–Ω–Ω—ã–µ –≤ URL –ø–æ—Å–ª–µ `?`
2. **FormValue** ‚Äî –ø–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –∏–∑ —Ñ–æ—Ä–º
3. **POST/GET** ‚Äî —Ä–∞–∑–Ω—ã–µ –º–µ—Ç–æ–¥—ã –æ—Ç–ø—Ä–∞–≤–∫–∏
4. **ParseForm** ‚Äî –ø–∞—Ä—Å–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö —Ñ–æ—Ä–º—ã
5. **Multipart** ‚Äî –∑–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤

---

## üìã –°–∏–Ω—Ç–∞–∫—Å–∏—Å

### Query –ø–∞—Ä–∞–º–µ—Ç—Ä—ã

```go
r.URL.Query()           // –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
r.URL.Query().Get(key)  // –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä
```

### –î–∞–Ω–Ω—ã–µ —Ñ–æ—Ä–º—ã

```go
r.ParseForm()           // –ø–∞—Ä—Å–∏–Ω–≥ —Ñ–æ—Ä–º—ã
r.FormValue(key)        // –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è
r.PostFormValue(key)    // —Ç–æ–ª—å–∫–æ POST –¥–∞–Ω–Ω—ã–µ
r.Form[key]             // –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è (slice)
```

### –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤

```go
r.ParseMultipartForm(maxMemory)
file, header, err := r.FormFile(key)
```

---

## üíª –ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞

### –ü–æ–ª—É—á–µ–Ω–∏–µ Query –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤

```go
package main

import (
    "fmt"
    "net/http"
)

// URL: /search?q=golang&page=2
func searchHandler(w http.ResponseWriter, r *http.Request) {
    query := r.URL.Query()
    
    q := query.Get("q")
    page := query.Get("page")
    
    if page == "" {
        page = "1"
    }
    
    fmt.Fprintf(w, "Search: %s\nPage: %s", q, page)
}

func main() {
    http.HandleFunc("/search", searchHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### –û–±—Ä–∞–±–æ—Ç–∫–∞ HTML —Ñ–æ—Ä–º—ã (GET)

```go
package main

import (
    "fmt"
    "net/http"
)

// HTML —Ñ–æ—Ä–º–∞
const formHTML = `
<!DOCTYPE html>
<html>
<body>
    <form action="/greet" method="GET">
        <input type="text" name="name" placeholder="Your name">
        <button type="submit">Greet</button>
    </form>
</body>
</html>
`

func formHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, formHTML)
}

func greetHandler(w http.ResponseWriter, r *http.Request) {
    name := r.URL.Query().Get("name")
    if name == "" {
        name = "Guest"
    }
    fmt.Fprintf(w, "Hello, %s!", name)
}

func main() {
    http.HandleFunc("/", formHandler)
    http.HandleFunc("/greet", greetHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### –û–±—Ä–∞–±–æ—Ç–∫–∞ POST —Ñ–æ—Ä–º—ã

```go
package main

import (
    "fmt"
    "net/http"
)

const loginFormHTML = `
<!DOCTYPE html>
<html>
<body>
    <h2>Login</h2>
    <form action="/login" method="POST">
        <input type="text" name="username" placeholder="Username"><br><br>
        <input type="password" name="password" placeholder="Password"><br><br>
        <button type="submit">Login</button>
    </form>
</body>
</html>
`

func loginPageHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, loginFormHTML)
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Redirect(w, r, "/", http.StatusSeeOther)
        return
    }
    
    // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ —Ñ–æ—Ä–º—ã
    username := r.FormValue("username")
    password := r.FormValue("password")
    
    // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ (–Ω–µ –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞!)
    if username == "admin" && password == "secret" {
        fmt.Fprintf(w, "Welcome, %s!", username)
    } else {
        fmt.Fprint(w, "Invalid credentials")
    }
}

func main() {
    http.HandleFunc("/", loginPageHandler)
    http.HandleFunc("/login", loginHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### –§–æ—Ä–º–∞ —Å –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏

```go
package main

import (
    "fmt"
    "net/http"
    "strings"
)

const checkboxFormHTML = `
<!DOCTYPE html>
<html>
<body>
    <h2>Select your interests</h2>
    <form action="/interests" method="POST">
        <input type="checkbox" name="interest" value="go"> Go<br>
        <input type="checkbox" name="interest" value="python"> Python<br>
        <input type="checkbox" name="interest" value="javascript"> JavaScript<br>
        <input type="checkbox" name="interest" value="rust"> Rust<br><br>
        <button type="submit">Submit</button>
    </form>
</body>
</html>
`

func formHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, checkboxFormHTML)
}

func interestsHandler(w http.ResponseWriter, r *http.Request) {
    r.ParseForm()
    
    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
    interests := r.Form["interest"]
    
    if len(interests) == 0 {
        fmt.Fprint(w, "No interests selected")
        return
    }
    
    fmt.Fprintf(w, "Your interests: %s", strings.Join(interests, ", "))
}

func main() {
    http.HandleFunc("/", formHandler)
    http.HandleFunc("/interests", interestsHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤

```go
package main

import (
    "fmt"
    "io"
    "net/http"
    "os"
)

const uploadFormHTML = `
<!DOCTYPE html>
<html>
<body>
    <h2>Upload File</h2>
    <form action="/upload" method="POST" enctype="multipart/form-data">
        <input type="file" name="file"><br><br>
        <button type="submit">Upload</button>
    </form>
</body>
</html>
`

func uploadPageHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, uploadFormHTML)
}

func uploadHandler(w http.ResponseWriter, r *http.Request) {
    // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Ä–∞–∑–º–µ—Ä–∞: 10 MB
    r.ParseMultipartForm(10 << 20)
    
    file, header, err := r.FormFile("file")
    if err != nil {
        http.Error(w, "Error reading file", http.StatusBadRequest)
        return
    }
    defer file.Close()
    
    // –°–æ–∑–¥–∞—ë–º —Ñ–∞–π–ª –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ
    dst, err := os.Create("uploads/" + header.Filename)
    if err != nil {
        http.Error(w, "Error saving file", http.StatusInternalServerError)
        return
    }
    defer dst.Close()
    
    // –ö–æ–ø–∏—Ä—É–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ
    io.Copy(dst, file)
    
    fmt.Fprintf(w, "File %s uploaded successfully!", header.Filename)
}

func main() {
    os.MkdirAll("uploads", 0755)
    
    http.HandleFunc("/", uploadPageHandler)
    http.HandleFunc("/upload", uploadHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

### JSON –≤ —Ç–µ–ª–µ –∑–∞–ø—Ä–æ—Å–∞

```go
package main

import (
    "encoding/json"
    "fmt"
    "net/http"
)

type User struct {
    Name  string `json:"name"`
    Email string `json:"email"`
    Age   int    `json:"age"`
}

func createUserHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
        return
    }
    
    var user User
    
    err := json.NewDecoder(r.Body).Decode(&user)
    if err != nil {
        http.Error(w, "Invalid JSON", http.StatusBadRequest)
        return
    }
    
    fmt.Fprintf(w, "Created user: %s (%s), age %d", 
        user.Name, user.Email, user.Age)
}

func main() {
    http.HandleFunc("/users", createUserHandler)
    
    http.ListenAndServe(":8080", nil)
}

// –¢–µ—Å—Ç: curl -X POST -d '{"name":"John","email":"john@example.com","age":30}' localhost:8080/users
```

### –í–∞–ª–∏–¥–∞—Ü–∏—è —Ñ–æ—Ä–º—ã

```go
package main

import (
    "fmt"
    "net/http"
    "regexp"
    "strconv"
)

type RegistrationForm struct {
    Username string
    Email    string
    Age      int
    Errors   map[string]string
}

func (f *RegistrationForm) Validate() bool {
    f.Errors = make(map[string]string)
    
    if len(f.Username) < 3 {
        f.Errors["username"] = "Username must be at least 3 characters"
    }
    
    emailRegex := regexp.MustCompile(`^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$`)
    if !emailRegex.MatchString(f.Email) {
        f.Errors["email"] = "Invalid email format"
    }
    
    if f.Age < 18 || f.Age > 120 {
        f.Errors["age"] = "Age must be between 18 and 120"
    }
    
    return len(f.Errors) == 0
}

func registerHandler(w http.ResponseWriter, r *http.Request) {
    if r.Method != http.MethodPost {
        http.ServeFile(w, r, "register.html")
        return
    }
    
    age, _ := strconv.Atoi(r.FormValue("age"))
    
    form := RegistrationForm{
        Username: r.FormValue("username"),
        Email:    r.FormValue("email"),
        Age:      age,
    }
    
    if !form.Validate() {
        for field, err := range form.Errors {
            fmt.Fprintf(w, "%s: %s\n", field, err)
        }
        return
    }
    
    fmt.Fprintf(w, "Registration successful for %s!", form.Username)
}

func main() {
    http.HandleFunc("/register", registerHandler)
    
    http.ListenAndServe(":8080", nil)
}
```

---

## ‚ö†Ô∏è –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏

### 1. –ù–µ –≤—ã–∑–≤–∞–ª–∏ ParseForm

```go
// ‚ùå Form –º–æ–∂–µ—Ç –±—ã—Ç—å nil
values := r.Form["key"]

// ‚úÖ –°–Ω–∞—á–∞–ª–∞ –ø–∞—Ä—Å–∏–º
r.ParseForm()
values := r.Form["key"]
```

### 2. FormValue vs PostFormValue

```go
// FormValue –∏—â–µ—Ç –∏ –≤ URL, –∏ –≤ —Ç–µ–ª–µ
r.FormValue("key")  // GET –∏ POST

// PostFormValue ‚Äî —Ç–æ–ª—å–∫–æ –≤ —Ç–µ–ª–µ
r.PostFormValue("key")  // —Ç–æ–ª—å–∫–æ POST
```

### 3. –ó–∞–±—ã–ª–∏ enctype –¥–ª—è —Ñ–∞–π–ª–æ–≤

```go
// ‚ùå –§–∞–π–ª –Ω–µ –∑–∞–≥—Ä—É–∑–∏—Ç—Å—è
<form method="POST">

// ‚úÖ –ù—É–∂–µ–Ω enctype
<form method="POST" enctype="multipart/form-data">
```

---

## üìù –ü—Ä–∞–∫—Ç–∏–∫–∞

### –ó–∞–¥–∞—á–∞ 1: Contact form
–§–æ—Ä–º–∞ –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑–∏ —Å –≤–∞–ª–∏–¥–∞—Ü–∏–µ–π.

### –ó–∞–¥–∞—á–∞ 2: File uploader
–ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤ —Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π —Ç–∏–ø–∞.

### –ó–∞–¥–∞—á–∞ 3: Search with filters
–ü–æ–∏—Å–∫ —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏ —á–µ—Ä–µ–∑ query –ø–∞—Ä–∞–º–µ—Ç—Ä—ã.

### –ó–∞–¥–∞—á–∞ 4: Multi-step form
–ú–Ω–æ–≥–æ—à–∞–≥–æ–≤–∞—è —Ñ–æ—Ä–º–∞.

### –ó–∞–¥–∞—á–∞ 5: Image upload
–ó–∞–≥—Ä—É–∑–∫–∞ –∏ –ø—Ä–µ–≤—å—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π.

### –ó–∞–¥–∞—á–∞ 6: CSV import
–ò–º–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –∏–∑ CSV —Ñ–∞–π–ª–∞.

### –ó–∞–¥–∞—á–∞ 7: Registration
–ü–æ–ª–Ω–∞—è —Ñ–æ—Ä–º–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏.

### –ó–∞–¥–∞—á–∞ 8: API —Å JSON
–ü—Ä–∏—ë–º –∏ –æ—Ç–ø—Ä–∞–≤–∫–∞ JSON –¥–∞–Ω–Ω—ã—Ö.
